# 汇编笔记 

<p align="right"><i><font color=#0000FF> ——made by njtech_计2104 Melody</font></i></p>

[TOC]



## 引言

汇编语言是一种低级编程语言，它允许程序员直接与计算机的硬件交互。尽管现代的高级编程语言更常用且更易于学习，但学习汇编语言可以提供对计算机工作方式的深入理解，尤其是对于计算机内存、CPU 和操作系统。

> **常见的汇编语言**：
>
> 1. **x86汇编：** x86汇编用于x86架构的微处理器，如Intel和AMD的处理器。
>
>    > 2021年9月上架的“机械革命蛟龙7”笔记本的CPU处理器为“AMD Ryzen 9 5900HX”，是一种AMD处理器
>    >
>    > 2023年4月上架的“联想拯救者9000P”笔记本的CPU处理器为 "i9-13900HX"，是一种intel处理器
>
> 2. **ARM汇编：** ARM汇编语言主要用于ARM架构的微处理器。这种架构常用于嵌入式系统和移动设备，如智能手机和平板电脑。
>
> 这些汇编语言的主要区别在于它们对应的硬件架构和指令集。例如，x86架构是一种复杂指令集计算（CISC）架构，它有大量的指令和复杂的寻址模式。而ARM和MIPS则是精简指令集计算（RISC）架构，指令数量较少，结构更简单。
>
> Windows和Linux使用x86汇编，主要是因为x86架构的微处理器（如Intel和AMD的处理器）长期以来一直是个人电脑和服务器市场的主导。x86架构具有丰富的软件兼容性和强大的性能，使其成为这些系统的理想选择。
>
> **在本文中，我们只介绍x86汇编语言**



写于2023年5月18日，笔者为一名上课从来没有听过老师上课的大二学生，在上午的一整个上机课中，老师没有告诉你编译环境和调试器是如何运作，以及明明是这一门针对低层的编程代码，却仍像学C++，python一样生硬套代码。缺乏对低层硬件的了解，我们恐怕很难深入学习汇编语言。因此，我将以层层递进的角度，结合处理器的功能结构出发，尽可能做到知其然并知其所以然。在本文中，存在列举大量额外知识点的情况，有些情况下我们并不需要全部仔细读完(例如上文出现了汇编语言的列举)，只是为了在宏观的角度看待一个问题。



## 什么是汇编？

<img src="http://124.221.95.230:9001/markdown/imgs/image-20230627182011730.png" alt="image-20230627182011730" style="zoom:50%;" />

这是一块主板，是计算机系统中最重要的组件之一。上面集成了多个插槽、插座、接口和电子元件，用于连接和安装处理器（CPU）、内存（RAM）、扩展插槽（PCIe、AGP等）、硬盘（SATA、M.2等）、显卡、声卡、网卡和其他外围设备。

假设你打开了电脑，将文件从C盘移动到了D盘，这其中就需要“处理器”来进行移动处理，在windows桌面上你能直观的看到一个文件从一个地方移动到另一个地方，这其实已经是非常上层的操作了，而我们聚焦的是最底层的，直接对处理器进行交互的代码。

<img src="http://124.221.95.230:9001/markdown/imgs/5fdf8db1cb1349549250e7ce87d6685ed0094a69.jpeg" style="zoom:50%;" />

这是一块由Intel公司于1978年推出的一款16位微处理器——8086处理器，让我们来看看他的组成部分

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/30adcbef76094b3658a39d26775486df8c109d6c.jpeg" style="zoom:50%;" />



1. **Adder**（加法器）：Adder是8086处理器中的一部分，用于执行加法运算
2. **Upperregs**（上部寄存器）：Upperregs是8086处理器中的一组寄存器，包括AX、BX、CX和DX。它们是通用寄存器，
3. **Lowerregs**（下部寄存器）：Lowerregs是8086处理器中的另一组通用寄存器，包括SP、BP、SI和DI。这些寄存器同样是16位的，用于存储数据和地址。
4. **ALU**（算术逻辑单元）：ALU是8086处理器中的关键组件，负责执行算术和逻辑运算。它能够执行加法、减法、乘法、除法和逻辑运算，如与、或、非等。
5. **Control**（控制单元）：Control是处理器中的控制部分，负责协调和控制处理器的各个组件。它从内存中读取指令，解码并分发给相应的部件执行。
6. **Decode**（译码器）：Decode是一个重要的组件，用于解码指令。
7. **Microcode**（微码）：Microcode是一种指令级别的控制信息，用于控制处理器内部的操作。



在计算机中，理论上你可以输入“00000000 00000010”然后交给处理器，处理器的译码器会将它解码并交给微码，于是就执行了“对AX寄存器累加10”的操作。

但实际编程中，谁会输入“00000000 00000010”呀！根本不利于我们进行编程，于是就诞生了汇编语言，汇编器会将汇编语言转化成机器码后交给处理器。



汇编语言是一种低级程序设计语言，它非常接近计算机硬件的操作。每条汇编语言指令对应于计算机的一条机器语言指令。在早期的计算机编程中，汇编语言被广泛地使用。

**每种计算机硬件架构都有其自己的汇编语言版本，这是因为每种硬件都有其自己的机器语言**。因此，汇编语言指令直接对应于特定的计算机硬件的操作。

在编程中，使用汇编语言的一个主要优势是可以提供对硬件的精确控制，以及编写高效的代码。然而，学习和编写汇编语言的代码通常比使用更高级的语言（如C，Java，Python等）要困难得多，这是因为它需要对硬件的详细知识。

例如，让我们来看一下这样一条汇编语言指令：

```assembly
MOV AL, 61h
```

在这条指令中，"MOV"是操作码，它表示要执行的操作（在这个例子中，是"移动"或"复制"操作）。"AL"是操作数，表示要操作的数据（在这个例子中，是寄存器AL）。"61h"是另一个操作数，表示要复制到AL寄存器的数据（在这个例子中，是十六进制数61）。

这条指令的含义是：将十六进制数61（在十进制中为97）复制到AL寄存器。这就是一个简单的汇编语言指令，你可以想象一下，一个完整的程序需要很多这样的指令。因此，尽管汇编语言提供了对硬件的强大控制，但它的使用确实需要付出大量的努力。



就njtech的教学而言，本门课程基于x86架构的8086处理器进行学习。



## 学习路线

学习x86汇编语言的路线可以如下：

1. **基本概念：** 首先，你需要理解计算机的基本组成，比如中央处理器（CPU）、内存（RAM）、硬盘等。理解二进制和十六进制的基础知识是非常重要的，因为在汇编语言中，你会频繁地接触这两种数制。同时，你也需要理解什么是指令集，以及x86架构的基本特性。
2. **环境设置：** 安装一个汇编器，比如NASM，以及一个适合你的文本编辑器或集成开发环境（IDE）。你也可能需要一个调试器，比如GDB，它可以帮助你理解你的代码在执行时发生了什么，从而找出可能存在的问题。
3. **学习基本语法和指令：** 理解汇编语言的基本语法，包括如何定义数据、如何进行算术运算、如何控制程序流程等。你需要学习一些基本的汇编指令，比如`mov`（移动或复制数据）、`add`（加法）、`sub`（减法）、`jmp`（跳转到程序的另一部分）等。
4. **编程实践：** 开始编写一些简单的汇编程序，比如实现两个数字的加法运算、一个简单的循环结构等。通过编程实践，你可以更好地理解汇编语言的工作方式。
5. **理解寄存器：** 寄存器是CPU中的一种非常快速的存储设备。在x86汇编中，你会频繁地操作寄存器。理解每个寄存器的功能，以及如何使用它们，是非常重要的。
6. **内存管理：** 学习如何在汇编语言中操作内存，包括如何加载和存储数据，如何分配和释放内存等。
7. **系统调用：** 学习如何在汇编语言中进行系统调用，以实现一些更复杂的功能，比如读写文件、接收用户输入等。
8. **理解中断和异常：** 中断和异常是计算机系统中的重要概念。理解它们的工作原理，以及如何在汇编语言中处理它们，是学习x86汇编的重要部分。
9. **阅读复杂的代码：** 当你掌握了基本的概念和技巧后，你可以开始阅读一些更复杂的汇编代码，以提高你的技能。这可能包括一些开源的汇编程序，或者一些著名的操作系统

```mermaid
graph LR
A(基本概念) --> B(环境设置) --> C(学习基本语法和指令) --> D(编程实践) --> E(理解寄存器) --> F(内存管理)--> G(系统调用) --> H(理解中断和异常)  --> I(阅读复杂的代码) 
```



## 第一个汇编程序

### 配置环境

1. 下载 [Visual Studio Code](https://code.visualstudio.com/)

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518085712043.png" alt="image-20230518085712043" style="zoom: 33%;" />

2. 安装 MASM/TASM 插件

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518085831223.png" alt="image-20230518085831223" style="zoom:50%;" />

3. 配置DOS的环境和选择编译器

   点击扩展设置

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518090056154.png" alt="image-20230518090056154" style="zoom: 33%;" />

   配置以下设置

   ![image-20230518090132970](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518090132970.png)

现在，你可以在代码页中右键菜单中运行代码了

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518090231037.png" alt="image-20230518090231037" style="zoom: 50%;" />



在配置环境中，你使用了 **MASM** 作为汇编工具，使用 **dosbox** 作为DOS环境模拟器，下面我们将介绍 **dosbox**.



### 什么是dosbox？

DOSBox是一个开源的模拟器，用于模拟早期的DOS（Disk Operating System）操作系统环境。它的主要目的是在现代的操作系统中运行旧的DOS程序。

> DOS（Disk Operating System）是一种磁盘操作系统，最早由微软（Microsoft）开发。它最初是为IBM的个人计算机（PC）设计的，于1981年与IBM PC一起发布，并成为早期个人计算机的主要操作系统。以下是DOS的历史和当今现状的简要介绍：
>
> 1. DOS的特点：
>    - 命令行界面：DOS采用基于文本的命令行界面，用户通过键入命令来执行操作。
>    - 单任务操作系统：早期的DOS版本是单任务操作系统，只能同时运行一个程序。
>    - 文件系统：DOS使用FAT（File Allocation Table）文件系统，后续版本引入了FAT32来支持更大的磁盘容量。
>    - 缺乏图形界面：早期的DOS版本没有图形用户界面（GUI），用户主要通过文本模式界面进行操作。
> 2. 当今现状：
>    - 历史地位：DOS在个人计算机的发展中起到了重要的推动作用，但随着图形用户界面和先进操作系统的崛起，如Windows、Mac OS和Linux，DOS已经逐渐退出了主流计算机市场。
>    - 嵌入式系统：尽管DOS在桌面计算机领域的影响力减弱，但它在嵌入式系统中仍然存在。一些嵌入式设备和专用系统仍在使用定制的DOS版本来实现特定的功能和控制。
>    - 怀旧和学习：一些人对DOS怀有情感，或者将其用作学习计算机历史和汇编语言编程的平台。DOSBox等模拟器使得在现代计算机上运行DOS程序成为可能。
>
> DOS在计算机发展史上具有重要的地位，虽然它在当前计算机市场中已经较少使用，但仍有人对其保持兴趣，并将其视为计算机技术的重要里程碑之一。

作为一个模拟器，他具备了调试的功能，因此在本次教程中不需要安装任何调试器。

> **什么是调试器？**
>
> 调试器是一个用于测试和调试其他程序的软件工具。当程序发生错误或异常时，调试器可以用于检查程序的内部状态，找出错误发生的原因。
>
> 调试器的主要功能包括：
>
> - **断点**：这是调试器中最常用的一个功能。断点可以设置在特定的代码行，当程序执行到这一行时，程序会暂停，这样你就可以检查此时程序的状态。
> - **单步执行**：这个功能可以让你一步一步地执行程序。每执行一步，你都可以看到程序状态的变化。
> - **变量查看和修改**：当程序暂停时，你可以查看和修改变量的值，这对于理解程序的行为和调试问题非常有用。
> - **调用栈查看**：调试器允许你查看程序的调用栈。调用栈是一个记录了函数调用历史的结构，通过查看调用栈，你可以知道程序是如何达到当前状态的。



### 编写代码

```assembly
data segment
    x db 30
data ends

code segment

    start:
        mov ax, data
        mov ds, ax
        
        mov al, ds:[x]

code ends

end start

```

使用“调试功能”，输入三次“t+回车”后，输入“d 076C:0000"即可看到结果

![image-20230627190933997](http://124.221.95.230:9001/markdown/imgs/image-20230627190933997.png)

“x=30”被正确赋值到了076C：0000上（十六进制的1E等于十进制的30）

看到这里，你或许充满着疑惑：代码写了什么？我为什么要这么做？结果为什么是这样？这是因为我什么也没有告诉你，请耐心阅读后续部分。



## 处理器-内存-存储器

试想一下这个场景：你的电脑有一款二字游戏，叫做《原神》，《原神》是由米哈游自主研发的一款全新开放世界冒险游戏。游戏发生在……

咳咳，跑题了，当你在打开游戏的时候，数据从硬盘中加载到了内存，然后被处理器调用，于是你就看到了进入游戏的大门，接着你操控角色的任何移动，本质上都是在改变内存中的数据，当你关闭游戏时，数据从内存中释放，一些基本数据如世界地图，场景等固定的数据将保存在硬盘中，这就是电脑的工作流程。

> 内存条（内存）和硬盘（存储器）一般插在主板上，主板一般配有对应的槽

因此，要想操作内存中的数据，首先就得找到数据在内存中的哪一块，这就是汇编中的一大重点——**寻址**，在介绍该部分之前，需要先介绍**寄存器**



## 寄存器

> [进位计数值](#进位计数制) 
>
> [数据组织方式](#数据组织方式)

寄存器（Register）是位于中央处理器（CPU）内部的能够快速存储和访问数据的存储单元.

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/30adcbef76094b3658a39d26775486df8c109d6c.jpeg" style="zoom:50%;" />





8086是一款16位微处理器，它拥有多个寄存器，这些寄存器可以分为几类：**通用寄存器**、**段寄存器**、**指针和索引寄存器**、**状态和控制寄存器**。以下是对这些寄存器的简要描述：

1. **通用寄存器**：包括AX、BX、CX和DX，这些寄存器可以进一步拆分为两个8位寄存器（如，AX可以拆分为AH和AL）。这些寄存器主要用于数据操作：
   - AX（累加器）：主要用于算术、逻辑和数据传输操作。
   - BX（基地址寄存器）：它可以作为一个指针来使用，用于数据操作。
   - CX（计数寄存器）：通常在循环和字符串操作中用作计数器。
   - DX（数据寄存器）：通常用于I/O操作和某些乘法和除法操作。
2. **段寄存器**：包括CS、DS、SS和ES，这些寄存器用于存储当前正在使用的代码、数据和堆栈段的地址：
   - CS（代码段寄存器）：存储当前执行代码的地址。
   - DS（数据段寄存器）：存储当前使用的数据段的地址。
   - SS（堆栈段寄存器）：存储当前使用的堆栈段的地址。
   - ES（附加段寄存器）：作为数据段寄存器的补充，存储额外的数据段地址。
3. **指针和索引寄存器**：包括SP、BP、SI和DI，这些寄存器通常用于字符串操作和内存访问：
   - SP（堆栈指针）：指向堆栈顶部的指针。
   - BP（基址指针）：主要用于堆栈段的数据访问。
   - SI（源索引）：主要用于字符串操作，指向源数据。
   - DI（目标索引）：主要用于字符串操作，指向目标数据。
4. **状态和控制寄存器**：包括IP和Flags：
   - IP（指令指针）：存储下一条将要执行的指令的地址。
   - Flags（标志位）：用于存储处理器的状态信息，例如零标志（ZF）、进位标志（CF）、符号标志（SF）等。<a name="flags"> </a>



尽管你可以把一些数据从AX移动到BX上（即混淆每个寄存器的作用），但我并不建议你这么做，因为有一些底层设计是专门针对不同寄存器而设计的。例如，循环指令会判断“CX”是否为零，如果不为零则进行减一操作并进入循环，如果把CX当做数据寄存器来使用势必会出错。

寄存器的种类很多，功能用法也不一致，详细请参考[寄存器使用指南](#寄存器使用指南)





## 寻址

实模式（Real Mode）和保护模式（Protected Mode）是x86体系结构中的两种工作模式。8086处理器采用的是**实模式**，至于什么是保护模式，不在本文范围内，请读者自行查阅。

8086处理器一共有20条**总线**。在处理器中，**总线**是一组电子线路或信号线，用于在计算机内部的不同组件之间传输数据、地址和控制信号。说白了就是多少条总线，一次性就能传多少位数据。
$$
\mathrm{2^{20}=1,048,576=1 \mathrm{M}}
$$
然而，寄存器最多只能存16位，如何用16位的寄存器来解决20位地址寻址的问题？

在8086微处理器中，一个完整的物理地址是由一个16位的段地址和一个16位的偏移地址组合而成的。具体的计算方式是：将段地址左移4位（也就是乘以16，或者说乘以十六进制的1000h），然后再加上偏移地址。这种方式允许我们从两个16位的值生成一个20位的物理地址。

对于段地址和偏移地址，我的理解是真的只是为了定义而起了两个名字，没有什么特殊的含义，你只需要知道，在计算机的表示格式为“段地址：偏移地址”即可。

> 在表示地址中，尽管寄存器为16位，但并不会以"0000 0000 0000 0000 "来表示，因为这样太长且不利于阅读，因此采用16进制来表示，比如："1011 1000 1111 0001" 对应的16进制数为"B8F1" ，

以“1234:1234” 地址为例，他的20位地址计算图如下：

<img src="http://124.221.95.230:9001/markdown/imgs/image-20230521174417254.png" alt="image-20230521174417254" style="zoom:67%;" />



## 解读第一个汇编程序



### 编程入门

在**x86汇编语言**中，代码由段（segment）组成，在运行时，代码会被以内存的方式存储在内存中，段的定义方式为：

```assembly
段名 segment

段名 ends
```



在代码中，你还需要指定函数的入口（类似于C++的 `int main()` ）与高级编程语言不同，函数的入口名不是一个关键字，你只需要在代码的末尾 `end` 中指定入口名即可：

```assembly
code1 segment

	kaishi:

code1 ends

end kaishi:
```



由此可见，段和入口名均可自定义，但为了规范，还是建议按照功能来命名，其中对于段，可以有4个种类：

1. 代码段（Code Segment）：这个段通常包含了程序的指令。即程序的机器代码，例如：

   ```assembly
   code segment
       mov ax, data
       mov ds, ax
   code ends
   ```
   
2. 数据段（Data Segment）：这个段通常包含了程序的数据。比如变量、常量、数组等，例如：

   ```assembly
   data segment
       message db 'Hello, World!', '$'
   data ends
   ```

3. 堆栈段（Stack Segment）：这个段用来存放程序的运行堆栈。它被用于临时存储数据和返回地址，例如：

   ```assembly
   stack segment
       dw 128 dup(0)
   stack ends
   ```

4. 额外段（Extra Segment）：这个段可以用来存放额外的数据，它通常被用于字符串或者其他大量数据的操作。



对于代码段，我们可以发现，一段完整的代码通常由 “ 操作指令 参数A [ , 参数B ] ” 组成，下面介绍前文出现过的操作指令：







### 调试

Debug是一个在MS-DOS和一些Windows环境下的命令行调试工具。你可以使用它来执行、调试和测试程序。在Debug环境下，你可以使用如下的一些指令：

1. **-t（Trace）**：这个指令可以让你单步执行程序。每次执行一条指令后，Debug会显示CPU的状态，包括寄存器的值和标志的状态。
2. **-g（Go）**：这个指令可以让你开始或继续运行程序，直到程序结束，或者遇到一个断点。
3. **-p（Proceed）**：这个指令和"g"指令类似，但是它会在每次调用或返回指令后暂停程序的执行。
4. **-r（Register）**：这个指令可以让你查看和修改寄存器的值。
5. **-d（Dump）**：这个指令可以让你查看内存的内容。
6. **-e（Enter）**：这个指令可以让你修改内存的内容。
7. **-a（Assemble）**：这个指令可以让你在内存中输入汇编语言指令。
8. **-u（Unassemble）**：这个指令可以让你将内存中的机器代码反汇编为汇编语言指令。
9. **-q（Quit）**：这个指令可以让你退出Debug。



在了解了代码究竟在写什么之后，我们一起来看看调试模式下的“第一个汇编程序”发生了什么

在 **vscode** 中右键代码选择 "调试当前程序(汇编+链接+调试" 然后输入"r" 

![image-20230521202626502](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521202626502.png)

该结果告诉了如下信息：

- 所有寄存器的值（从AX到IP），

- "NU UP EI PL NZ NA PO NC"这些是处理器的状态标志，表示不同的处理器条件。这些标志由CPU在执行指令后自动设置或清除，表示特定的条件或状态（如零标志（Z）、进位标志（C）、溢出标志（O）、符号标志（S）等）。
- "076D:0000 B86C07 MOV AX, 076C"表示当前（下一个要执行的）指令（在地址076D:0000）是将076C这个值移入AX寄存器。



接着，我们可以输入"t"

![image-20230521203150047](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521203150047.png)

对比上图，我们可以发现，"AX" 的值已经变为"076C" 下一指令是"把AX的地址移动到DS上"，我们接着输入"t"

![image-20230521203257209](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521203257209.png)

对比上图，我们可以发现，“移动”的本质就是拷贝了一份地址，由此，我们可以看到“DS”寄存器的值也变为了“076C”，而除了告诉我们下一指令是移动以外，在右边还出现了新的提示“DS:0000 = 1E ” 意思是该地址的值是20，我们可以输入"d 076C:0000" 验证一下

![image-20230521203530193](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521203530193.png)

这部分的信息量有点大，我们逐一解释：首先，左边的一列代表了地址，中间每一行（16个）展示了每个地址对应的子节信息（以16进制表示），右边则排列对应子节的ASCll字符。举个例子， 对于地址"076C:0000" 他的值是1E(即20)，由于他的ASCll无法以正常的字符表示，所以他默认为".",对于地址"076C:68",他的值是74（即116），对应字符"t"

> 其实中间的"-" 没有任何意义，他写出来是为了方便你看那16个数字，不然看到眼睛痛 —。—

> 两个16进制恰好能表示8位二进制，1子节指的就是8位二进制



我们接着输入"t" 查看

![image-20230521204247244](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521204247244.png)

在前文，我们已经知道，对于一个16位寄存器，还可以分为两个8位寄存器(高位和低位)，因此在该操作中，我们把“30”这一个值移动到了AX的低位寄存器（AL）上，注意，一旦我们进行了数据移动操作后，16位寄存器已经不为一个正确的存地址的寄存器（上图071E是一个未知的地址，因此不能当地址用）



至此，你已经入门了x86汇编，后文将结合课程安排分版块介绍不同的功能







## x86编程



### 寄存器使用指南

| 通用寄存器 | 段寄存器 | 指针和索引寄存器 | 状态和控制寄存器 |
| ---------- | -------- | ---------------- | ---------------- |
| AX         | CS       | SP               | IP               |
| BX         | DS       | BP               | Flags（标志位）  |
| CX         | SS       | SI               |                  |
| DX         | ES       | DI               |                  |



#### 通用寄存器

##### AX（累加器）

在8086微处理器中，AX是一个16位的累加器。它是一种常用的通用寄存器，也是一种专用寄存器。由于它的大小，它可以处理16位的二进制数据。它可以分为两个8位的寄存器：AH（高8位）和AL（低8位）。

通用寄存器是在各种计算和数据操作中使用的寄存器，而专用寄存器是为特定任务而设计的。在许多指令中，AX通常用作操作数的源或目标。

例如，ADD指令可以用来将两个寄存器的内容相加，结果存放在一个寄存器中，如下面的指令：

```
MOV AX, 1234h   ; 把1234h（十六进制数）移动到AX寄存器
MOV BX, 4321h   ; 把4321h（十六进制数）移动到BX寄存器
ADD AX, BX      ; 将AX寄存器和BX寄存器的内容相加，结果存放在AX中
```

在这个例子中，我们将1234h和4321h两个值相加，结果5555h会存储在AX寄存器中。

然而，我们也可以操作AX寄存器的一部分，如AH和AL，例如：

```
MOV AL, 12h     ; 把12h（十六进制数）移动到AL寄存器
MOV AH, 34h     ; 把34h（十六进制数）移动到AH寄存器
ADD AL, AH      ; 将AL寄存器和AH寄存器的内容相加，结果存放在AL中
```

在这个例子中，我们将12h和34h两个值相加，结果46h会存储在AL寄存器中。

有一些操作指令不会显式调用AX，如：

1. `DIV` 指令：无符号除法，将一个32位的被除数（DX：AX）除以一个16位的除数，产生一个16位的商和一个16位的余数。

   ```assembly
   MOV AX, 1000h    ; 被除数
   MOV DX, 0        ; 清零DX寄存器，准备存储余数
   MOV BX, 10       ; 除数
   
   DIV BX           ; 执行除法操作，结果保存在AX和DX中
   
   ; 此时AX中存储商，DX中存储余数
   
   ```

   如果DX不清零，假设为0002，那么被除数就是“00021000”而不是“00001000”，将会出现错误

2. `int 21h` 指令：`int 21h` 是一个软件中断指令，用于调用DOS（Disk Operating System）功能。通过在 `ah` 寄存器中设置特定的功能号，可以使用`int 21h`来执行各种与DOS相关的操作。下面列一些 `int 21h` 调用的含义和作用：

   - 功能号`01h`：
     - 含义：从标准输入获取一个字符。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中。
   - 功能号`08h`：
     - 含义：从标准输入获取一个字符（无回显）。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，但不在屏幕上显示字符。
   - `int 21h`，功能号`0Ah`：
     - 含义：从标准输入获取一个字符并缓冲。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，同时将其缓冲以供后续读取。
   - `int 21h`，功能号`0Ch`：
     - 含义：获取当前打印页号。
     - 作用：将当前打印页号存储在`al`寄存器中。

##### BX（基地址寄存器）

在8086微处理器中，BX是一个16位寄存器，可以用于存储数据和地址。它可以分为两个8位的寄存器：BH（高8位）和BL（低8位）。

一般情况下，BX可以在许多常规操作中用于存储或接收数据。例如：

```assembly
MOV BX, 1234h ; 把1234h（十六进制数）移动到BX寄存器
MOV AX, BX    ; 将BX寄存器的值复制到AX寄存器
```

然而，BX寄存器在8086中有一个特殊的角色，那就是它可以用作一个基址寄存器。这意味着BX可以用来保存一个内存地址，然后可以用这个地址来访问内存。例如：

```assembly
MOV BX, 1234h   ; 把1234h（十六进制数）作为地址移动到BX寄存器
MOV AL, [BX]    ; 从内存地址1234h处取一个字节到AL寄存器
```

类似的，我们也可以操作BX寄存器的一部分，如BH和BL：

```assembly
MOV BL, 12h     ; 把12h（十六进制数）移动到BL寄存器
MOV BH, 34h     ; 把34h（十六进制数）移动到BH寄存器
ADD BL, BH      ; 将BL寄存器和BH寄存器的内容相加，结果存放在BL中
```



##### CX（计数寄存器）

在8086微处理器中，CX是一个16位的寄存器，它可以分为两个8位的寄存器：CH（高8位）和CL（低8位）。

CX寄存器在8086中的主要用途是作为循环计数器。例如，在执行循环或重复前缀的字符串操作时，CX寄存器用于存储循环次数或字符串操作的次数。当然，除此之外，CX寄存器也可以被用作一般目的寄存器。

例如，以下是一段使用CX作为循环计数器的代码片段：

```assembly
MOV CX, 10     ; 设置循环计数为10
LOOP_START:    ; 循环开始的标签
    ; ...这里是要执行的代码...
DEC CX         ; 减少循环计数
JNZ LOOP_START ; 如果CX不为0，跳转回循环开始
```

在这个例子中，程序将会执行循环内的代码10次。每执行一次，CX的值就会减1，当CX的值为0时，循环结束。



##### DX（数据寄存器）

在8086微处理器中，DX是一个16位的寄存器，它可以分为两个8位的寄存器：DH（高8位）和DL（低8位）。

一种常见的情况是在执行**乘法和除法运算**时，DX寄存器被用作辅助寄存器。例如，在16位乘法和除法中，AX和DX寄存器一起形成一个32位的数。在乘法运算中，AX寄存器保存低16位，DX寄存器保存高16位。在除法运算中，被除数存储在DX和AX中（DX为高16位，AX为低16位），商存储在AX中，余数存储在DX中。

```assembly
MOV AX, 1000h   ; 设置被除数的低16位
MOV DX, 0002h   ; 设置被除数的高16位
DIV BX          ; 将32位数DX:AX除以BX，商存储在AX中，余数存储在DX中
```

有一些操作指令不会显式调用AX，如：

1. `int 21h` 指令：`int 21h` 是一个软件中断指令，用于调用DOS（Disk Operating System）功能。通过在 `ah` 寄存器中设置特定的功能号，可以使用`int 21h`来执行各种与DOS相关的操作。下面列一些 `int 21h` 调用的含义和作用：
   - 功能号`02h`：
     - 含义：将字符输出到标准输出。
     - 作用：将`dl`寄存器中的字符显示在屏幕上。



#### 段寄存器

##### CS（代码段寄存器）

在8086处理器中，CS（代码段）寄存器是一个16位的寄存器，它被用于保存当前正在执行的代码段的基地址。在分段内存管理模型中，整个内存被划分为多个段，每个段有一个基地址和一个长度。段寄存器（例如CS）存储着相应段的基地址，而内存中的具体位置则由段寄存器和一个偏移地址共同决定。

例如，如果CS的值是1234h，IP（指令指针）寄存器的值是5678h，那么处理器会在物理内存地址12340h + 5678h = 179B8h处查找下一条要执行的指令。注意这里的地址计算是通过将CS的值左移4位（或乘以16）然后加上IP的值得到的。

CS寄存器的值通常在以下情况下改变：

- 当执行一个跳转或调用指令到一个新的代码段时，CS的值会被更新为新的代码段的地址。
- 当发生中断或异常时，处理器会自动保存当前的CS和IP的值，然后加载新的CS和IP的值来处理中断或异常。

注意，由于CS寄存器用于保存代码段地址，所以在大多数情况下，程序员不能直接修改它的值。CS寄存器的值通常在跳转、调用、返回、中断或异常处理等操作中被隐式地改变。

以下是一些使用CS寄存器的示例：

```assembly
JMP 1234h:5678h ; 跳转到物理地址12340h + 5678h处执行代码，CS被设置为1234h，IP被设置为5678h

CALL 1234h:5678h ; 调用位于物理地址12340h + 5678h处的过程，CS被设置为1234h，IP被设置为5678h

; 在中断服务例程中，处理器会自动保存CS和IP的值，然后加载新的CS和IP的值
```



##### DS（数据段寄存器）

在8086微处理器中，DS（数据段）寄存器是一个16位的寄存器，它被用于保存当前数据段的基地址。数据段通常是存储程序数据（如变量和常量）的地方。

在分段内存管理模型中，整个内存被划分为多个段，每个段有一个基地址和一个长度。段寄存器（例如DS）存储着相应段的基地址，而内存中的具体位置则由段寄存器和一个偏移地址共同决定。

例如，如果DS的值是1234h，BX（基址寄存器）的值是5678h，那么处理器会在物理内存地址12340h + 5678h = 179B8h处查找或存储数据。注意这里的地址计算是通过将DS的值左移4位（或乘以16）然后加上BX的值得到的。

DS寄存器的值通常在以下情况下改变：

- 当程序需要访问一个新的数据段时，DS的值需要被更新为新的数据段的地址。

以下是一些使用DS寄存器的示例：

```assembly
MOV AX, 1234h   ; 将1234h（十六进制数）移动到AX寄存器
MOV DS, AX      ; 将AX寄存器的值移动到DS寄存器，设置数据段的基地址

MOV BX, 5678h   ; 将5678h（十六进制数）移动到BX寄存器，设置偏移地址
MOV AL, [BX]    ; 从物理地址12340h + 5678h处读取一个字节到AL寄存器

MOV [BX], AL    ; 将AL寄存器的值写入到物理地址12340h + 5678h处
```

> 这里的 `mov ax, 1234h` 和 `mov ds, ax` 的用法是由8086处理器的硬件设计和汇编语言的语法规则决定的。
>
> 首先，`1234h` 是一个立即数，在这里可以假设其代表了数据段在内存中的起始地址。
>
> 在8086处理器的架构中，一些特殊的寄存器，如段寄存器（包括 DS），由于它们的特殊用途，对于它们能接受的操作和数据有一定的限制。在这种情况下，不能直接将一个立即数加载到段寄存器中，所以不能直接执行 `mov ds, 1234h` 这样的操作。
>
> 因此，为了将数据段的地址加载到 DS 寄存器，需要先将地址加载到一个通用寄存器（ AX）中，然后再将该通用寄存器的值（寄存器操作数）加载到 DS 寄存器中。这就是为什么需要 `mov ax, 1234h` 和 `mov ds, ax` 这两步操作的原因。
>
> 这样的设计可能会让人感到有些繁琐，但它也反映出了早期微处理器设计的一些历史和技术背景，以及在有限的硬件资源和复杂性之间寻找平衡的结果。
>
> 关于立即数的概念，详见[操作数](#操作数)

##### SS（堆栈段寄存器）

在8086微处理器中，SS（堆栈段）寄存器是一个16位的寄存器，它被用于保存当前堆栈段的基地址。堆栈是一种特殊的数据结构，其特性是后进先出（Last-In-First-Out，LIFO）。在程序中，堆栈常被用于存储局部变量、函数参数、返回地址等信息。

##### ES（附加段寄存器）

#### 指针和索引寄存器

##### SP

##### BP

##### SI

##### DI

#### 状态和控制寄存器

##### IP

##### flags



### 操作数

你已经知道，一段完整的代码通常由 “ 操作指令 参数A [ , 参数B ] ” 组成，这里的参数其实就是指操作数。提供操作数的方式有**立即数**，**寄存器操作数** ，**内存操作数**：

1. 立即数：立即数是指直接给出的具体数值或常数，它们直接在指令中被指定。例如，在`MOV AX, 1234h`这条指令中，1234h就是一个立即数。立即数在执行时直接被用于计算，它们不需要从内存或寄存器中取出。

2. 寄存器操作数：寄存器操作数是指在寄存器中存储的值。这些值可以是数值，也可以是内存地址。寄存器操作数在执行时被直接从寄存器中取出。例如，在`MOV DS, AX` 这条指令中，AX就是一个寄存器操作数。

3. 内存操作数：内存操作数是指存储在内存中的值。内存操作数需要通过地址来获取，这个地址可以直接在指令中给出，也可以通过寄存器或其他方式来指定。例如，在`MOV AL, [BX]`这条指令中，[BX]指定了一个内存地址，该地址中的值就是一个内存操作数。



### 功能号与int中断指令

`int 21h` 是一个软件中断指令，用于调用DOS（Disk Operating System）功能。通过在`ah`寄存器中设置特定的功能号，可以使用`int 21h`来执行各种与DOS相关的操作。下面列一些 `int 21h` 调用的含义和作用：

1. - `int 21h`，功能号`00h`：
     - 含义：程序终止。
     - 作用：终止程序的执行。
   - `int 21h`，功能号`01h`：
     - 含义：从标准输入获取一个字符。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中。
   - `int 21h`，功能号`02h`：
     - 含义：将字符输出到标准输出。
     - 作用：将`dl`寄存器中的字符显示在屏幕上。
   - `int 21h`，功能号`06h`：
     - 含义：将字符输出到标准输出（无回显）。
     - 作用：将`dl`寄存器中的字符显示在屏幕上，但不在屏幕上显示光标。
   - `int 21h`，功能号`08h`：
     - 含义：从标准输入获取一个字符（无回显）。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，但不在屏幕上显示字符。
   - `int 21h`，功能号`09h`：
     - 含义：显示字符串。
     - 作用：将存储在`dx`寄存器指向的字符串输出到屏幕上。
   - `int 21h`，功能号`0Ah`：
     - 含义：从标准输入获取一个字符并缓冲。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，同时将其缓冲以供后续读取。
   - `int 21h`，功能号`0Ch`：
     - 含义：获取当前打印页号。
     - 作用：将当前打印页号存储在`al`寄存器中。

#### 常用功能号

| AH   | 描述                               |
| ---- | ---------------------------------- |
| 00h  | 程序终止                           |
| 01h  | 从标准输入获取一个字符             |
| 02h  | 将字符输出到标准输出               |
| 06h  | 将字符输出到标准输出（无回显）     |
| 08h  | 从标准输入获取一个字符（无回显）   |
| 09h  | 显示字符串                         |
| 0Ah  | 从标准输入获取一个字符并缓冲       |
| 0Ch  | 获取当前打印页号                   |
| 0Eh  | 将字符输出到标准输出并保留光标位置 |
| 25h  | 设置DOS版本号                      |
| 2Ch  | 获取系统时间                       |
| 30h  | 获取DOS版本号                      |
| 33h  | 设置断点                           |
| 35h  | 获取磁盘参数                       |
| 3Dh  | 打开文件                           |
| 3Eh  | 关闭文件                           |
| 3Fh  | 读取文件                           |
| 40h  | 写入文件                           |
| 4Bh  | 加载和执行程序                     |
| 4Ch  | 程序终止，并返回错误级别           |



### CMP与跳转指令

`CMP` 是比较指令，用于比较两个值。并根据比较结果设置处理器的状态标志。如果结果显示 `参数1` 的值【条件】 `参数2` 的值，则设置处理器的状态标志

以 `JAE` 为例，他的含义是"**不小于跳转**" 当 `参数1` 的值大于等于 `参数2` 的值时将跳转。

以下是一些与 `CMP` 指令相关的常用条件跳转指令：

- `JE`（Jump if Equal）：如果比较结果为相等，则跳转。
- `JNE`（Jump if Not Equal）：如果比较结果为不相等，则跳转。
- `JG`（Jump if Greater）：如果比较结果为大于，则跳转。
- `JGE`（Jump if Greater or Equal）：如果比较结果为大于或等于，则跳转。
- `JL`（Jump if Less）：如果比较结果为小于，则跳转。
- `JLE`（Jump if Less or Equal）：如果比较结果为小于或等于，则跳转。
- `JA`（Jump if Above）：如果无符号数比较结果为大于，则跳转。
- `JAE`（Jump if Above or Equal）：如果无符号数比较结果为大于或等于，则跳转。
- `JB`（Jump if Below）：如果无符号数比较结果为小于，则跳转。
- `JBE`（Jump if Below or Equal）：如果无符号数比较结果为小于或等于，则跳转。



### LEA计算地址

`LEA` 是汇编语言中的一条指令，全称为 "Load Effective Address"，中文可以翻译为 "加载有效地址"。

`LEA` 指令用于计算有效地址并将结果存储在目标寄存器中。有效地址是指操作数（通常是内存地址）的真实地址。`LEA` 指令计算的是操作数的地址，而不是操作数本身的值。

通常情况下，`LEA` 指令的操作数是一个内存地址表达式，可以是一个偏移量、基址加上一个索引乘以一个缩放因子，或者其他更复杂的组合。`LEA` 指令计算出这个内存地址表达式的结果，并将其存储在目标寄存器中。

例如，下面是一个示例：

```assembly
LEA SI, array ; 将数组 array 的地址加载到 SI 寄存器
```

这行代码将数组 `array` 的地址计算出来，并将其存储在 `SI` 寄存器中。这样，`SI` 寄存器就包含了数组 `array` 的起始地址，我们可以使用 `SI` 寄存器来访问数组的元素。

除了 `SI`（Source Index）寄存器之外，还有以下寄存器可以作为 `LEA` 指令的目标寄存器：

- `DI`（Destination Index）：用于目标地址的索引。
- `BX`（Base Index）：用于基地址的索引。
- `BP`（Base Pointer）：用于基地址的指针。
- `SP`（Stack Pointer）：用于栈指针。

这些寄存器可以作为目标寄存器，接收 `LEA` 指令计算出的有效地址。使用 `LEA` 指令，我们可以在不访问内存的情况下计算出有效地址，并将其存储在目标寄存器中，以便后续使用。





## 上机作业一

上机过程和DEBUG介绍:了解并掌握汇编语言源程序。上机练习的过程(四个步骤)：编辑、汇编、连接和调试。

题目一：Debug调试程序

题目二：X=30，Y=15，求 X + Y, X - Y，X * Y分别保存至 z1，z2， z3 变量中。



下面使用 **Debug** 调试程序完成题目二的内容。

```assembly
data segment
    x db 30
    y db 15
    z1 db ?
    z2 db ?
    z3 dw ?
data ends

code segment

    start:
        mov ax, data
        mov ds, ax

        mov al, ds:[x]
        add al, ds:[y]
        mov ds:[z1], al

code ends

end start

```

![image-20230521210538243](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521210538243.png)

1. 关于MUL指令：`MUL`指令在8086汇编语言中是用来进行无符号乘法操作的。这个指令只接受一个操作数，它会将这个操作数与`AL`（如果操作数是8位的）或`AX`（如果操作数是16位的）寄存器的内容相乘，然后将结果放置在`AX`（如果操作数是8位的）或`DX:AX`（如果操作数是16位的）寄存器对中。所以，当你执行`MUL ds:[y]`时，实际上你是在将`y`的值与`AL`寄存器的内容相乘，所以不需要再次指定`ds:[x]`。

2. 为在8086处理器中，乘法结果的存储方式是小端序（Little Endian）。小端序是指在多字节数据中，最低有效字节在最低的内存地址，最高有效字节在最高的内存地址。这意味着如果一个16位数存储在两个字节中，低字节将被首先存储。

   在本题中，30*15等于450。如果我们将450转换为十六进制，我们将得到`01C2`。在小端序中，它将以`C2 01`的形式存储。所以，当检查`DS:0004`（即`z3`）时，你看到的是`C2`，这是450的低8位部分。如果你继续查看下一个字节`DS:0005`，你应该能看到`01`，这是450的高8位部分。



## 上机作业二

题目一：统计学生成绩设有10个学生的成绩分别为46、68、88、87、76、89、99、65、 100和80分。试编制程序统计低于60分、60~69 分、70~79分、 80~89 分、90~99分及100分的人数，并存放到S5、S6、S7、S8、S9及S10单元中。

```assembly
data segment
    scores db 46, 68, 88, 87, 76, 89, 99, 65, 100, 80
    S5 db 0
    S6 db 0
    S7 db 0
    S8 db 0
    S9 db 0
    S10 db 0
data ends

code segment

    start:
        mov ax, data
        mov ds, ax
        mov cx, 10 ; 分数数量
        lea bx, scores ; bx指向分数数组

        count_loop:
            mov al, [bx] ; 读取分数
            cmp al, 60
            jb below60
            cmp al, 70
            jb from60to69
            cmp al, 80
            jb from70to79
            cmp al, 90
            jb from80to89
            cmp al, 100
            jb from90to99
            jmp is100

        below60:
            inc byte ptr ds:[S5]
            jmp next_score

        from60to69:
            inc byte ptr ds:[S6]
            jmp next_score

        from70to79:
            inc byte ptr ds:[S7]
            jmp next_score

        from80to89:
            inc byte ptr ds:[S8]
            jmp next_score

        from90to99:
            inc byte ptr ds:[S9]
            jmp next_score

        is100:
            inc byte ptr ds:[S10]

        next_score:
            inc bx ; 移动到下一个分数
            loop count_loop ; 如果还有分数则重复循环

        int 3  ; 中断指令，用于打断点
            
        

    code ends
end start

```

![image-20230521212905759](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521212905759.png)



题目二：对键盘键入的小写字母用大写字母显示出来；若键入的为非字母键，则程序结束。

```assembly
data segment
    prompt db 'Please enter a character: $'
    output db 'Your character: $', 0
    newline db 0Dh, 0Ah, '$' ; newline (CR LF)
data ends

code segment
    start:
        mov ax, data
        mov ds, ax

        get_input:

            lea dx, prompt
            mov ah, 09h
            int 21h ; 将存储在`dx`寄存器指向的字符串输出到屏幕上。

            mov ah, 01h
            int 21h ; 等待用户从键盘输入一个字符，并将其存储在`al`寄存器中。

            ; 比较字符
            cmp al, 'a'
            jb end_program
            cmp al, 'z'
            ja end_program

            ; 转换为大写字符
            sub al, 20h

            display_output:
                mov dl, al
                mov ah, 02h
                int 21h ; 将`dl`寄存器中的字符显示在屏幕上。


                lea dx, newline
                mov ah, 09h    
                int 21h ; 输出回车

                jmp get_input

        end_program:
            mov ah, 4Ch
            int 21h ; Terminate program

code ends
end start

```

![image-20230521215846389](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521215846389.png)



在ASCII编码中，换行通常由两个字符表示：回车（CR，ASCII值为13或0Dh）和换行（LF，ASCII值为10或0Ah）。

这种表示方式起源于打字机和电传打印机的操作方式：回车（CR）是移动打印头到行首，而换行（LF）是移动纸张到下一行。在现代计算机系统中，通常一起使用这两个字符来表示换行。



## 上机作业三

题目一：找出一个字节数组中最大数和最小数，分别存入 MAX 和 MIN 单元中(假设字节数组为 45,98,63,78,88,101,89,65,100)



首先定义数据段 **data** 

```assembly
DATA SEGMENT
    array DB 45,98,63,78,88,101,89,65,100
    count DW 9 ; 假设数组长度为9
    MAX DB ?
    MIN DB ?
DATA ENDS
```

为了方便后面找数据不写 `ds:` 可以写个假设

```assembly
ASSUME DS:DATA, CS:CODE
```

在 `START` 中初始化

```assembly
START:
        MOV AX, DATA
        MOV DS, AX ; 将数据段地址加载到DS
        
        ; 初始化 CX 为数组长度
        MOV CX, count	;CX(计数寄存器)

        ; 将数组第一个元素加载到 MAX 和 MIN
        MOV AL, array[0]
        MOV MAX, AL
        MOV MIN, AL
        
        ; 假设 DI 指向数组的下一个元素
        MOV DI, 1
```

- CX（计数寄存器）：通常在循环和字符串操作中用作计数器。

在 `COMPARE` 中开始循环。

```assembly
COMPARE:
        CMP DI, CX
        JAE FINISH ; 如果 DI 大于等于 CX 说明已比较所有元素 跳转 FINISH

        MOV AL, array[DI] ; 加载数组的下一个元素
        
        CMP AL, MAX
        JA GREATER ;如果 AL 大于 MAX 说明AL更大一些，跳转GREATER修改最大值
        
        CMP AL, MIN
        JB LESS
        
        JMP NEXT
```

当执行 `CMP DI, CX` 指令时，它会比较寄存器DI和CX中的值，并根据比较结果设置处理器[标志位](#flags)。具体来说，该指令执行以下操作：

1. 将DI和CX中的值相减：`DI - CX`
2. 检查结果并设置相应的标志位：
   - 如果结果为零（DI和CX相等），则将零标志位（ZF）设置为1。
   - 如果结果为正数（DI大于CX），则将进位标志位（CF）设置为0，零标志位（ZF）设置为0。
   - 如果结果为负数（DI小于CX），则将进位标志位（CF）设置为1，零标志位（ZF）设置为0。

`JAE FINISH` 指令会检查"无借位相等（Unsigned Greater than or Equal）"标志位（CF和ZF）是否被设置，如果被设置，则跳转到`FINISH`标签处执行。因此 `JAE` 指令的作用是 **不小于跳转**



执行 `CMP AL, MAX` 和 `JA GREATER` 时，操作逻辑与之类似，唯一不同的是 `JA ` 是 **大于跳转**



执行 `CMP AL, MIN` 和 `JB LESS` 时，操作逻辑与之类似，唯一不同的是 `JB ` 是 **小于跳转**



```assembly
GREATER:
    MOV MAX, AL ; 如果当前元素更大，则更新 MAX
    JMP NEXT

LESS:
    MOV MIN, AL ; 如果当前元素更小，则更新 MIN
```

`GREATER` 和 `LESS` 的操作类似，在更新后跳转到 `NEXT ` 中

```assembly
NEXT:
    INC DI ; 移动到数组的下一个元素
    JMP COMPARE
```

`INC ` 是一个递增语句，在这里，他将 `DI `  的值进行递增会返回到 `DI `中

```assembly
FINISH:
        int 3  ; 中断指令，用于打断点

        MOV AX, 4C00H
        INT 21H
```

最后，使用调试模式，输入"-g" 执行到中断指令后输入"-d 076C:0000" 即可看到结果



![image-20230525091842901](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525091842901.png)



完整代码：

```assembly
DATA SEGMENT
    array DB 45,98,63,78,88,101,89,65,100
    count DW 9 ; 假设数组长度为9
    MAX DB ?
    MIN DB ?
DATA ENDS

CODE SEGMENT
    ASSUME DS:DATA, CS:CODE
    START:
        MOV AX, DATA
        MOV DS, AX ; 将数据段地址加载到DS
        
        ; 初始化 CX 为数组长度
        MOV CX, count

        ; 将数组第一个元素加载到 MAX 和 MIN
        MOV AL, array[0]
        MOV MAX, AL
        MOV MIN, AL
        
        ; 假设 DI 指向数组的下一个元素
        MOV DI, 1

    COMPARE:
        CMP DI, CX
        JAE FINISH ; 如果我们已经比较了所有元素，则结束

        MOV AL, array[DI] ; 加载数组的下一个元素
        CMP AL, MAX
        JA GREATER
        CMP AL, MIN
        JB LESS
        JMP NEXT

    GREATER:
        MOV MAX, AL ; 如果当前元素更大，则更新 MAX
        JMP NEXT

    LESS:
        MOV MIN, AL ; 如果当前元素更小，则更新 MIN

    NEXT:
        INC DI ; 移动到数组的下一个元素
        JMP COMPARE

    FINISH:
        int 3  ; 中断指令，用于打断点

        MOV AX, 4C00H
        INT 21H
    CODE ENDS
END START

```





作业二：统计字变量 X 中的各位有多少个 1，并将结果存入到 NUM 单元中(假设X=97B4H)。

首先定义数据段 **data** 

```assembly
DATA SEGMENT
    X DW 97B4H
    NUM DB 0
DATA ENDS
```

同样为了省事假设一下

```assembly
ASSUME DS:DATA, CS:CODE
```

在 `START` 中加载数据

```assembly
START:
    MOV AX, DATA
    MOV DS, AX ; 将数据段地址加载到DS

    MOV AX, X ; 加载 X 到 AX
    MOV CX, 16 ; 初始化位数为 16
```

之后我们在 `COUNT_ONES` 中实现计数循环

```assembly
COUNT_ONES:
    SHL AX, 1 ; 将 AX 左移一位
    JNC SKIP_INCREMENT ; 如果进位标志位没有被设置，即最高位不是1，跳过增量
    INC NUM ; 如果进位标志位被设置，即最高位是1，增加 NUM
```

`SHL` 是汇编语言中的一个指令，全称为 "Shift Logical Left"，中文可以翻译为 "逻辑左移"。

逻辑左移指令会将指定寄存器的内容向左移动指定的位数。在移动过程中，左边移出的位会进入进位标志（CF），右边空出的位会被填充为0。

例如，假设 `AX` 寄存器的内容为 `0001 0001b`（也就是十进制的17），那么执行 `SHL AX, 1` 后，`AX` 寄存器的内容会变为 `0010 0010b`（也就是十进制的34）。你可以看到，原本在 `AX` 寄存器的每一位都被向左移动了一位，原本最左边的位（也就是最高位）被移出并进入进位标志，最右边空出的位被填充为0。

`JNC` 指令来检查进位标志。如果进位标志被设置，则会执行跳转命令

```assembly
SKIP_INCREMENT:
    LOOP COUNT_ONES ; 循环，直到 CX 为 0
```

最后打个断点看看结果

```assembly
EXIT:
    int 3
    MOV AX, 4C00H
    INT 21H
```

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525101123104.png" alt="image-20230525101123104" style="zoom:80%;" />

完整代码

```assembly
DATA SEGMENT
    X DW 97B4H
    NUM DB 0
DATA ENDS

CODE SEGMENT
    ASSUME DS:DATA, CS:CODE
    START:
        MOV AX, DATA
        MOV DS, AX ; 将数据段地址加载到DS
        
        MOV AX, X ; 加载 X 到 AX
        MOV CX, 16 ; 初始化位数为 16
        
    COUNT_ONES:
        SHL AX, 1 ; 将 AX 左移一位
        JNC SKIP_INCREMENT ; 如果进位标志位没有被设置，即最高位不是1，跳过增量
        INC NUM ; 如果进位标志位被设置，即最高位是1，增加 NUM

    SKIP_INCREMENT:
        LOOP COUNT_ONES ; 循环，直到 CX 为 0

    EXIT:
        int 3
        MOV AX, 4C00H
        INT 21H
    CODE ENDS
END START

```



## 上机作业四

作业一：根据成绩数组 score 中保存的 10 个学生的成绩，统计相应学生的名次并填入 名次数组 rank 中(假设 10 名学生的成绩为 80,60,49,86,100,79,85,86,99,59)



首先定义数据段 **data**

```assembly
DATA SEGMENT
    score DW 80,60,49,86,100,79,85,86,99,59 ; 成绩数组
    rank DW 10 DUP(0) ; 名次数组
    total_students DW 10 ; 总学生数
DATA ENDS
```

老生常谈的假设

```assembly
ASSUME DS:DATA, CS:CODE
```

要实现排名，需要双层循环，我们可以用伪代码表示这一过程：

```
for(student1 in student_number1){
	for (student2 in student_number2){
		if (student1[score] > student2[score])
			student1[rank]++
	}
}
```

因此我们需要两个内存地址来存储两个 `student_number` ，在本题中，我们使用 `CX` 计数寄存器来存储外层循环 `student_number1`

在 `START ` 中初始化

```assembly
START:
    MOV AX, DATA ; 将数据段地址加载到AX
    MOV DS, AX ; 将数据段地址加载到DS
    MOV CX, total_students ; 将总学生数加载到CX，用于外层循环
    LEA BX, score ; 将score数组的地址加载到BX
    LEA DI, rank ; 将rank数组的地址加载到DI
```

LEA (Load Effective Address) 指令用于计算有效地址并将其存储在目标寄存器中。通常，LEA指令用于计算地址表达式而不是用于内存访问。

在这段代码中，`LEA SI, score`将score数组的地址加载到SI寄存器中。这样SI就可以在内层循环中用于遍历score数组。

简单来说，LEA指令计算其操作数的地址，然后将结果存储在目标寄存器中。这里的操作数通常是一个内存地址表达式。这就是为什么你经常会看到LEA与数组或结构体一起使用：因为它们的名字实际上就是它们在内存中的地址。

接着，我们在 `SET_RANK` 中正式开始排名,在本题中，我们使用栈来存储内层循环 `student_number2`

```assembly
SET_RANK:
    PUSH CX ; 将CX压入堆栈，因为内层循环会修改它
    MOV DX, [BX] ; 将当前学生的成绩加载到DX
    MOV CX, total_students ; 将总学生数加载到CX，用于内层循环
    LEA SI, score ; 将score数组的地址加载到SI
    MOV AX, 1 ; 初始化名次为1
```

`SET_RANK` 实现了外层循环，具体逻辑是：将 `CX` 压入堆栈，`CX` 在上文中是 `MOV CX, total_students ` ，他代表了`student1`。`DX` 和`SI` 分别存储了学生的顺序和对应的成绩，而经过了`MOV CX, total_students` 后，现在的`CX` 充当了内层循环中的`student_number2`，至此，所有外层循环已经铺垫好，开始进入内层循环

```assembly
    COMPARE_SCORES:
        CMP DX, [SI] ; 将当前学生的成绩和其他学生的成绩进行比较
        JAE NEXT ; 如果当前学生的成绩不低于其他学生的成绩，跳到下一个学生
        INC AX ; 否则，名次加1
NEXT:
    ADD SI, 2 ; 将SI加2，移动到下一个学生的成绩
    LOOP COMPARE_SCORES ; 重复内层循环，直到比较了所有学生的成绩
    MOV [DI], AX ; 将计算出的名次存储到rank数组中
    ADD BX, 2 ; 将BX加2，移动到下一个学生的成绩
    ADD DI, 2 ; 将DI加2，移动到下一个学生的名次
    POP CX ; 从堆栈中弹出CX，恢复外层循环的计数器
    LOOP SET_RANK ; 重复外层循环，直到计算了所有学生的名次
```

`DX` 代表着`student1[score]` 在进行了 `CMP `比较后,如果该学生成绩低于第二位学生，则名次加一，然后进入 `NEXT` ，首先将 `SI` 加2（因为我们这里都是双子节 所以要移动两位），移动到下一个学生的成绩 然后重复内层循环，在比较完所有学生后，获得了当前学生的名次 `AX ` ，把该数据存储到`DI `中并+2 ，移动到下一个学生的名次，同时移动`BX` 来实现外层循环移动到下一个同学



总的来说 `CX ` 是一个很重要的变量，他利用栈同时充当了外层循环`student_number1` 和内层循环`student_number2` 的角色，同时利用`BX` 和`SI` 遍历每个学生，再将成绩存储到`DI` 中，最后利用`LEA SI, score` 重新加载成绩数组。

<img src="C:\Users\MR\Nutstore\1\我的坚果云\图片\image-20230525110451124.png" alt="image-20230525110451124" style="zoom:67%;" />



完整代码

```assembly
DATA SEGMENT
    score DW 80,60,49,86,100,79,85,86,99,59 ; 成绩数组
    rank DW 10 DUP(0) ; 名次数组
    total_students DW 10 ; 总学生数
DATA ENDS

CODE SEGMENT
ASSUME DS:DATA, CS:CODE
    START:
        MOV AX, DATA ; 将数据段地址加载到AX
        MOV DS, AX ; 将数据段地址加载到DS
        MOV CX, total_students ; 将总学生数加载到CX，用于外层循环
        LEA BX, score ; 将score数组的地址加载到BX
        LEA DI, rank ; 将rank数组的地址加载到DI
    SET_RANK:
        PUSH CX ; 将CX压入堆栈，因为内层循环会修改它
        MOV DX, [BX] ; 将当前学生的成绩加载到DX
        MOV CX, total_students ; 将总学生数加载到CX，用于内层循环
        LEA SI, score ; 将score数组的地址加载到SI
        MOV AX, 1 ; 初始化名次为1
        COMPARE_SCORES:
            CMP DX, [SI] ; 将当前学生的成绩和其他学生的成绩进行比较
            JAE NEXT ; 如果当前学生的成绩不低于其他学生的成绩，跳到下一个学生
            INC AX ; 否则，名次加1
    NEXT:
        ADD SI, 2 ; 将SI加2，移动到下一个学生的成绩
        LOOP COMPARE_SCORES ; 重复内层循环，直到比较了所有学生的成绩
        MOV [DI], AX ; 将计算出的名次存储到rank数组中
        ADD BX, 2 ; 将BX加2，移动到下一个学生的成绩
        ADD DI, 2 ; 将DI加2，移动到下一个学生的名次
        POP CX ; 从堆栈中弹出CX，恢复外层循环的计数器
        LOOP SET_RANK ; 重复外层循环，直到计算了所有学生的名次
    EXIT:
        int 3
        MOV AX, 4C00H ; 将退出代码加载到AX
        INT 21H ; 调用中断，退出程序
    CODE ENDS
END START

```



## 上机作业五

商品数组products中按照商品ID(0-9之间)保存的每样商品对应的价格(假设价格为整数)，从键盘输入需要购买的⼀组商品的ID(假设⼀次性购买商品不超过10件)，计算需要购买商品的总价，并显示出来。假设商品的价格为55,10,25,13,90,5,15,24,68,20(id为0~9)

1. 在输入子程序的时候，如果输入的个数是10个，自动打印个换行出来；如果最后的输入是换行符，则无需再次打印换行。

   1. 具体实现的时候可以将10放入CX中，然后进行Loop循环，循环体内调用输入中断，从键盘输入⼀个字符放入AL中，在这里需要判断输入的字符是不是换行，如果是换行使用JMP指令跳出Loop循环，如果不是换行，则进行保存，输入的字符转化为数字保存到数组中。
   2. 使用JMP指令相当于C语言中的break跳出循环，但是当循环正常结束的时候（我们输入10个id后）需要在后面打印⼀个换行。判断循环是否正常结束我们可以通过判断CX的0是不是0来实现。

   ```assembly
   cmp al,0dh ;判断输⼊的是不是换⾏
   blank DB 0DH,0AH,'$';打印换⾏的语句
   mov dx,offset blank
   mov ah,09h
   int 21h
   ```

2. 在进制转换的时候，可以在从网上查找相关资料，结合栈的技术完成16进制转化为10进制，并在屏幕显示。

   1. 如果我们把23H转化为10进制，并输出，举例进行说明。
   2. 首先，23H/10，商4余9，我们把余数进栈，此时栈底到栈顶的元素依次为9;商保存留作下次
      除10使用。
   3. 4/10商0余4，我们把余数进栈，此时栈底到栈顶的元素依次为9 4;商为0，跳出循环。
   4. 这个时候我们从栈顶依次弹出元素，弹出的元素分别为49，49就是23H的十进制表达。

   ```asm
   MOV DL,48 ; ⼗进制的48对应的ASCII值为0
   MOV AH，0200H
   int 21H ;会将字⺟0打印到屏幕上
   MOV AH 0100H
   int 21H ;系统产⽣中断，直⾄从键盘录⼊⼀个字符⾄AL寄存器中
   ```

   



## 附录



### 课程安排

> 本部分整理自南京工业大学王兴亚老师的ppt

- 第1部分：基础知识（2课时）
  - 了解汇编语言的定义，掌握进位计数制，理解计算机中的数据组织，掌握二进制数的算术及逻辑运算
- 第2部分： 80x86计算机组织结构（2课时）
  - 掌握计算机系统的基本概念和基本组成，掌握80x86的系统结构，寄存器和存储器组织方式，80x86 CPU的工作模式
- 第3部分：指令系统和寻址方式（6课时）
  - 掌握汇编语言中指令的书写方法、寻址方式；能根据不同的寻址方式找到正确的物理地址单元；掌握80x86常用指令
- 第4部分：程序结构（4课时）
  - 理解汇编语言编写程序的两种基本框架，掌握汇编语言的指令格式，掌握汇编语言的数据、运算符与表达式的正确使用，掌握常用伪指令的使用
- 第5部分：顺序、分支、循环程序设计（6课时）
  - 理解和掌握程序设计的基本控制结构及不同结构程序设计的方法和技巧
- 第6部分：子程序设计（4课时）
  - 掌握子程序的结构和设计方法，理解主程序和子程序的调用关系及子程序调用和返回过程，掌握多模块程序设计的基本方法、各模块之间的参数调用及连接方法
- 第7部分：高级汇编技术（2课时）
  - 理解宏指令与子程序的区别。掌握宏定义的结构，宏定义、宏调用与宏展开的使用，宏库的建立和使用。掌握重复汇编的几种格式
- 第8部分：输入/输出与中断（6课时）
  - 理解中断的概念和作用，掌握80X86中断系统中有关中断分类、中断向量表以及中断过程等内容，会设置中断向量并编写相应的中断服务程序，了解BIOS中断和DOS中断的区别，掌握常用的BIOS和DOS中断类型



### 进位计数制

十六进制中，1位可以表示的数有：1,2,3,4,5,6,7,8,9,A,B,C,D,E. 十进制转十六进制的方法是取余法，十六进制转十进制的方法是按权累加法。书写十六进制时，一般习惯在后面加一个“H”代表这是一个十六进制数。要注意十六进制数A～F书写时的前导0：

如：   MOV AL，B7H（错误）

应为：MOV AL，0B7H（正确）



### 数据组织方式

- 位（Bit）
  - 位是计算机中表示信息的最小单位，单位符号是b，是一个二进制位，每一位用二进制的“0”或“1”表示。
- 字节（Byte）
  - 8位二进制数为1个字节， 单位符号是B，每个字节为8位二进制数。
  - 1个字节可以表示28个不同的值，即0 ~ 255（用二进制表示为：00000000B ~ 11111111B），共256个不同的值.
- 字（Word）
  - 字是在操作中作为一个单元处理的一组数据。一般1个字包含2个字节，1个字可以表示216个不同的值 。
- 双字（Double Word）
  - 2个字节为1个字，4个字节为2个字，也称为双字
  - 1个双字可以表示232个不同的值，即0 ~ 4294967295（用十六进制表示为：00000000H ~ FFFFFFFFH），共4294967296个不同的值。
- 字长
  - 机器字的长度为字长，是计算机中每个字所包含的位数，一般由**机器数据总线数**决定。
  - 8088/8086 CPU 为16位数据总线数，因此，8088/8086 CPU的机器字长为16位，也称为16位机。



### 三码：原码补码反码

在计算机中，需要有一位来表示数值的正负情况，因此人们约定为：在数值前有一个符号位，其0表示正，其1表示负

![image-20230524215954268](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230524215954268.png)

例如，“+1011”的表示为“01101”，“-1101”的表示为“11101”.

这种表示法叫做**机器码**，下面介绍的**原码，反码，补码**都是**机器码**



#### 原码

在上文已经介绍过，原码就是单纯的在前面加了一个符号位

#### 反码

正数反码与原码完全相同，负数反码的数值位按位取反

- “1011”的反码为“1011”
- “[1]1.01"的反码为"[1]0.10"

#### 补码

正数补码与原码完全相同，负数补码的数值位按位取反后再加1

- “1011”的反码为“1011”

- “[1]1.01"的反码为"[1]0.11"







### 文件类型

以下是一些常见的与汇编相关的文件类型及其用途：

1. **.asm：** 这是汇编源代码文件。这些文件包含用汇编语言编写的程序源代码。这些代码是人类可读的，并且可以通过汇编器转换成机器语言。
2. **.o / .obj：** 这些是目标文件。当你运行汇编器时，它会将你的.asm源代码文件转换成.obj或.o的目标文件（文件后缀取决于你使用的操作系统）。这些目标文件包含了机器语言代码，但不能直接执行，因为它们还没有被链接到可以在你的系统上运行的可执行文件。
3. **.exe / .out / .bin：** 这些是可执行文件。链接器取.obj或.o的目标文件，并将它们链接成一个可以在你的系统上直接运行的可执行文件。在Windows中，这些文件通常有.exe的扩展名，在Unix或类Unix系统（如Linux或macOS）中，它们通常没有扩展名或有.out、.bin等扩展名。
4. **.lib / .a：** 这些是库文件。它们包含一组可以被其他程序复用的目标文件。在Windows中，这些文件通常有.lib的扩展名，在Unix或类Unix系统中，它们通常有.a的扩展名。
5. **.dll / .so：** 这些是动态链接库文件。它们包含一组在运行时可以被其他程序调用的函数和数据。在Windows中，这些文件通常有.dll的扩展名，在Unix或类Unix系统中，它们通常有.so的扩展名。

总的来说，这些文件类型共同参与了程序的编译、链接和运行过程。其中，`.asm` 文件是程序的源头，`.o/.obj` 、.`lib/.a`、`.dll/.so`文件是编译和链接过程中的中间产物，而 `.exe/.out/.bin` 文件则是最终的可执行程序。



### 常见的汇编器

以下是一些常见的汇编器：

1. **NASM（Netwide Assembler）：** NASM是一个开源的x86汇编器，它可以用于Windows、Linux和MacOS。NASM使用Intel语法，易于学习和使用，因此常常推荐给初学者。此外，NASM生成的目标文件可以与多种编译器生成的文件链接，提供了很大的灵活性。
2. **MASM（Microsoft Macro Assembler）：** MASM是Microsoft的官方汇编器，它也使用Intel语法。由于MASM与Microsoft的其他开发工具（如Visual Studio）集成得很好，所以如果你在Windows上进行开发，MASM可能会很有用。然而，MASM并不适用于非Windows系统。
3. **GAS（GNU Assembler）：** GAS是GNU项目的官方汇编器，它可以用于所有主流的操作系统。与NASM和MASM不同，GAS默认使用AT&T语法，这可能会让初学者觉得有些难以理解。然而，GAS也可以配置为使用Intel语法。
4. **YASM （Yet Another Assembler）**是一个开源的汇编器，设计目标是成为NASM（Netwide Assembler）的改进版，尤其是在64位和多平台支持方面。YASM与NASM相比，拥有更好的64位支持和更多的输出格式，同时也支持NASM的所有指令和宏。

对于初学者来说，NASM可能是最好的选择，因为它使用广泛，语法直观，且有大量的教学资源。而对于调试器，如果你在Linux或MacOS上工作，GDB是很好的选择。如果你在Windows上工作，你可能会发现OllyDbg的图形用户界面更加易用。





