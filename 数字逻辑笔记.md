# 数字逻辑笔记

<p align="right"><i><font color=#0000FF> ——made by njtech_计2104 Melody</font></i></p>

> 如果你一不小心跳到头部了，那就是刚好我更新笔记了🤣
>
> 2023年5月30日16:10:43：修复了余3码不正确的bug，修复了没有正常渲染的图片😥
>
> 2023年5月30日14:29:01：“大题指南”更新为“考试指南”，新增了触发器大全🤗
>
> 2023年5月30日13:33:56： 修复了“点平”文字错误😥
>
> 2023年5月30日13:31:43： 更新了优先编码器😎
>
> 2023年5月30日13:01:45 ：修复了第四章电路分析中标注错误的图片😥
>
> 2023年5月30日10:56:22 ：补充了电平时序逻辑电路时间图的画法解释😍



临近考试了，祝大家都能成功上岸

![image-20230530164506448](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530164506448.png)



## 引言

​		这篇笔记于2023年5月25日开始编写，于28日21:54:29完成所有骨架部分，剩下的重心会转向对题型的补充和知识点的再整理。在这篇笔记的背后，我有太多想感谢的人，是他们陪伴我的白天与黑夜的见证。在编写的过程中曾不止一次想过要放弃，但他们时刻鼓舞着我不要放弃，在各个方面为我提供了支持和帮助

![image-20230528221810160](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528221810160.png)

​		因此，我觉得这篇笔记并不只是一份学习资料，它更是一段珍贵的记忆，一段我们一起攀爬知识峰峦，一起探索知识海洋的旅程。在这个过程中，你们的鼓励、支持、以及宝贵的建议，都让我受益良多。而我所能做的，就是将你们的精神，在这篇笔记中继续燃烧，希望它能照亮更多同在学习路上的朋友。你们的无私与大爱，让我明白，学习并非孤独的旅程，而是一条连接彼此，共享知识，共同进步的道路。

​		以下是感谢名单（不分排名先后）
$$
\begin{array}{ccc ccc}
\text{平安甘喜乐} & \text{玉貔貅} & \text{Isecom!} & \text{四十二万岁} & \text{怪苏黍} & \text{清枫与酒} \\
\text{椿} & \text{AAA建材批发顾} & \text{云乐} & \text{Ternura} & \text{月蓟} & \text{及汝} \\
\text{} & \text{} & \text{} & \text{} & \text{} & \text{} \\
\end{array}
$$


​		

## 考试大纲(待整理)

**第一章 基本知识**

- 进制互转：二进制、八进制、十进制、十六进制之间的转换（送分题）
- 编码方案：格雷码，8421 码 余321
- 常见码：原码反码补码 负数



**第二章 逻辑代数基础**

- 逻辑代数、复合逻辑、卡诺图（直接考或者结合逻辑电路大题考）
- 代入、反演、对偶规则

（逻辑代数 很重要 直白的就是代数法化简 卡诺图如何表示函数 画图去解对应与或式  ）

**第三章 集成门电路与触发器**

- 各触发器的工作原理（图，与非门还是或非门不要搞错）（ss  同步ss  架空 5个角度去描述）（触发器之间的？？转换？？）
- 次态方程、约束方程、逻辑功能，各触发器之间的相互转换

（符号 为重点 怎么画 功能是什么 表达式是什么 ）

**第四章 组合逻辑电路**

- 电路分析
- 电路设计
- 竞争与险象的产生、判断和消除





**第五章 同步时序逻辑电路**

- 电路的描述方法：表达式、状态表、状态图、时间图或波形图
- 电路**分析与设计**（设计 可以从头到尾 1.根据逻辑问题画出原式状态图 2.根据原始状态图 去隐含表法画？？？ 3.化简后的状态进行二进制编码 4.用卡诺图配合选择的触发器去实现触发器的驱动方程和输出方程 5.画电路图）



**第六章 异步时序逻辑电路**

- 电路的**分析**（只考分析不考设计）



**第七章 中规模通用集成电路及其应用**

- 常用电路：二进制并行加法器、译码器、编码器、多路选择器、电路分配器、双时针4位二进制同步可逆计数器**74193**及转换成模小于16的计数器（书上例题）、集成定时器555的三个应用多谐振荡器

(中规模时序电路只考74193 注意：1.异步  暂态过渡 高位 2.其他转换)

（组合逻辑中规模：加法器（超前进位  全加器串行 ） 74138译码器 带优先级的编码器74142 数据选择器 数据分配器  要注意主线：函数发生器）



## 第一章 基本知识



### 名词概念

- **基数**：计数制中需要用到的数字的个数。例如：在十进制中，需要用到十个数字（0-9），因此十进制的基数是“10”

- **位权**：表明不同数位上数值大小的一个固定常数，见下表：

  | 名称 |            | 万     | 千     | 百     | 十     | 个     |
  | ---- | ---------- | ------ | ------ | ------ | ------ | ------ |
  | 数位 | $n$        | $5$    | $4$    | $3$    | $2$    | $1$    |
  | 位权 | $10^{n-1}$ | $10^4$ | $10^3$ | $10^2$ | $10^1$ | $10^0$ |

- **并列表示法**：又称位置计数法，其表达式为
  $$
  (N)_R=\left(K_{n-1} K_{n-2} \cdots K_1 K_0 \cdot K_{-1} K_{-2} \cdots K_{-m}\right)_R
  $$
  例如：$(1234)_{10}=(1 2 3 4)_{10}$

- **多项式表示法**：又称按权展开法，其表达式为
  $$
  \begin{aligned}
  (N)_R= & K_{n-1} \times R^{n-1}+K_{n-2} \times R^{n-2}+\cdots+K_1 \times R^1+K_0 \times R^0 \\
  & +K_{-1} \times R^{-1}+K_{-2} \times R^{-2}+\cdots+K_{-m} \times R^{-m} \\
  = & \sum_{i=-m}^{n-1} K_i R^i
  \end{aligned}
  $$
  例如：$(1234)_{10}=1\times10^4 + 2\times10^3 + 3\times10^2 + 4\times10^1$ 



### 进制转换



#### 二进制转十进制

很简单，直接将二进制按权展开即可，如

$$
\begin{aligned}
  (10110.101)_2 & =1 \times 2^4+1 \times 2^2+1 \times 2^1+1 \times 2^{-1}+1 \times 2^{-3} \\
  & =16+4+2+0.5+0.125 \\
  & =(22.625)_{10}
  \end{aligned}
$$




#### 十进制转二进制

要对整数和小数分别进行处理。其中，整数部分采用**除2取余法**，小数部分采用**乘2取整法**



对于整数，取余法在学习生涯中已学过，不再赘述。

以45为例，计算过程如下：

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230524214010163.png" alt="image-20230524214010163" style="zoom:67%;" />

即 $(45)_{10}=(101101)_2$





对于小数，所谓乘2，指的是每次都 **把小数部分取出来乘2** ，得到个位数部分，然后再 **把小数部分取出来乘2**：

以0.6875为例，计算过程如下：

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230524214105116.png" alt="image-20230524214105116" style="zoom:67%;" />



不是所有的小数都能被转化成二进制，采用 **0舍1入**

以0.323为例，计算过程如下：

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230524214549424.png" alt="image-20230524214549424" style="zoom: 67%;" />

所谓 **0舍1入** 其实就是四舍五入的变种，即“**如果是0则舍去，如果是1则进一位**”

对于 $(0.01010)_2$ ，0舍1入的结果就是 $(0.0101)_2$





#### 二进制转八、十六进制

首先，你要明白一些恒等式：
$$
2^3=8^1 \\
2^4  = 16^1 
$$
你只需要理解一个感觉：”二进制的3(就是式子里的次幂数)就是八进制的1(就是式子里的次幂数)，二进制的4就是十六进制的1“。然后再来理解下面的转换：

$$
\begin{aligned}
(101 \space 001)_2 &\longrightarrow (51)_8 \\
(1010 \space 0001)_2 & \longrightarrow (\mathrm{A}1)_{16}
\end{aligned}
$$




二进制转八进制其实很简单，只需要将数字按3个3个分 然后把每部分的数值按转成十进制(之所以说十进制是方便理解)然后以此填入即可，例如上式中，“101”转过来就是“5”，“001”转过来就是“1”，所以八进制下的数值就是“51”，十六进制同理





### 三码：原码补码反码



#### 带符号的计算机码

在计算机中，需要有一位来表示数值的正负情况，因此人们约定为：在数值前有一个符号位，其0表示正，其1表示负

![image-20230524215954268](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230524215954268.png)

例如，“+1011”的表示为“01101”，“-1101”的表示为“11101”.

这种表示法叫做**机器码**，下面介绍的**原码，反码，补码**都是**机器码**



##### 原码

在上文已经介绍过，原码就是单纯的在前面加了一个符号位

##### 反码

正数反码与原码完全相同，负数反码的数值位按位取反

- “1011”的反码为“1011”
- “[1]1.01"的反码为"[1]0.10"

##### 补码

正数补码与原码完全相同，负数补码的数值位按位取反后再加1

- “1011”的反码为“1011”

- “[1]1.01"的反码为"[1]0.11"



> 为什么计算机要使用补码？
>
> > 待补充。。。这部分很想写的 但是写不完了





### 编码方案



#### BCD码

众所周知，$2^3=8$ 而 $2^4 =16$ 也就是说理论上4位二进制 可以表示十位数里面的十个数字，这就是BCD(Binary Coded Decimal)码的由来。为了方便使用十进制，通常限定每4位代表一个数字，例如：
$$
\begin{aligned}
0001\space  0002 &\longrightarrow (12 )_{10}  \\
\end{aligned}
$$
下面将介绍8421码，2421码，余3码以及可靠性编码
$$
\begin{array}{c|c|c|c}
\hline \text { 十进制字符 } & 8421 \text { 码 } & 2421 \text { 码 } & \text { 余 } 3 \text { 码 } \\
\hline 0 & 0000 & 0000 & 0011 \\
1 & 0001 & 0001 & 0100 \\
2 & 0010 & 0010 & 0101 \\
3 & 0011 & 0011 & 0110 \\
4 & 0100 & 0100 & 0111 \\
5 & 0101 & 1011 & 1000 \\
6 & 0110 & 1100 & 1001 \\
7 & 0111 & 1101 & 1010 \\
8 & 1000 & 1110 & 1011 \\
9 & 1001 & 1111 & 1100 \\
\hline
\end{array}
$$


##### 8421码

在上文已经介绍过，这就是最常见的BCD码：
$$
\begin{aligned}
& (258)_{10}=(0010\space0101\space1000)_{8421 码} \\
& (0001\space0010\space0000\space1000)_{8421 码}=(1208)_{10} \\
&
\end{aligned}
$$

##### 2421码

所谓2421意思就是4位二进制权重分别为 2 4 2 1.例如
$$
(1101)_{2421码}= 1\times2 +1\times4 +0\times 2 +1\times1 =(7)_{10}
$$
在4位二进制中，一共有16个数字，为保证和十进制一一对应，不允许出现 0101~1010 的6种状态

在2421码中存在一种特性，那就是 **对9的自补代码** 举个例子，4对9的补数是5，将4的2421码 $(0100)$ 取反得到 $(1011)$ 得到的2421码为 5的2421码



##### 余3码

余3码其实就是在8421码的基础上每个码加3，比如 $(0000)_{8421码}=(0011)_{余3码}$



#### 可靠性编码

以8421码为例，对于数字0和8的8421码
$$
(0)_{10} = (0000)_{8421码}\\
(8)_{10} = (1000)_{8421码}
$$
看起来挺好的，但现实是计算机也是会出错的，可能某个电压不稳定，可能有灰，可能什么磁场影响，一下子在某位数上跳了一下 从0变成了1，那么数值就发生了改变，从0变成了8，在实际生产中，为了减小这种错误带来的影响，我们要寻求一种编码能做到“**减少出错后带来的影响**” ,这就是**可靠性编码**。

请注意：**可靠性编码不一是BCD码，它主要研究在计算机中的编码**



##### 格雷码

格雷码的核心思想就是“**任意两个相邻数之间仅有一位不同**”，要实现这种思想，则需要用到异或运算“$\oplus$”具体计算见下例。

二进制数 $10110100$ 对应的格雷码为 $11101110$ 转换过程如下：

![image-20230525135351711](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525135351711.png)



##### 奇偶校验码

所谓校验码 就是在原来的码前面再加一位专门用来校验是否出错的校验位的码，根据奇偶可以分成两种，奇校验码和偶校验码。

奇校验码保证信息位和校验位的“1”的个数加起来是奇数，偶校验码保证信息位和校验位的“1”的个数加起来是偶数
$$
\begin{array}{c|c|c}
\hline \text { 信息位 } &  \text { 采用奇校验的校验位 } & \text { 采用偶校验的校验位 }  \\
\hline 1\space 0\space 0\space 1\space 1\space 0\space 1 & 1 & 0 \\
\end{array}
$$
很显然，如果同时出两个错的话（有两个“1”变成了“0”或者一个“0”变成了“1”或者两个“0”变成了“1”），奇偶校验码无法判断，后面有更高级的校验方式，不过这不在考试范围内了，详细可参考浮梁卖茶人的视频[【硬件科普】ECC内存是如何发现错误并纠正的？](https://www.bilibili.com/video/BV1GF411V7sC/?spm_id_from=333.999.0.0&vd_source=74f6820d52990caa91ca7aa786dcfb5b)





## 第二章 逻辑代数基础

### 逻辑代数

逻辑代数 $\mathrm{L}$ 是一个封闭的代数系统，记为 $\mathrm{L}=\{\mathrm{K},+,\cdot,-,0,1 \}$ ，其中 $\mathrm{K}$ 为逻辑变量集 ，满足下列公理





| 公理    | 式子1                                     | 式子2                                          |
| ------- | ----------------------------------------- | ---------------------------------------------- |
| 交换律  | $\mathrm{A+B=B+A}$                        | $\mathrm{ A\cdot B=B\cdot A}$                  |
| 结合律  | $\mathrm{(A+B)+C=A+(B+C)}$                | $\mathrm{(A\cdot B)\cdot C=A\cdot (B\cdot C)}$ |
| 分配律  | $ \mathrm{A+(B\cdot C)=(A+B)\cdot (A+C)}$ | $\mathrm{ A\cdot (B+ C)=A\cdot B+A\cdot C)}$   |
| 0 - 1律 | $\mathrm{A+0=A}$ <br>$\mathrm{A+1=1}$     | $\mathrm{A\cdot0=0}$<br>$\mathrm{A\cdot 1=A}$  |
| 互补律  | $\mathrm{A+\bar{A}=1 }$                   | $\mathrm{A\cdot\bar{A}=0 }$                    |



 每个逻辑变量之间满足 **或 与 非** 运算，不再阐述



### 逻辑函数的三种表示法

逻辑函数指的是某个逻辑电路输入逻辑变量后得到输出变量的这一转换关系
$$
F=f(\mathrm{A_1,A_2,\cdots ,A_n})
$$

1. 逻辑表达式

   逻辑表达式是由逻辑变量、逻辑运算符和必要的括号所构成的式子：
   $$
   F=f(\mathrm{A,B})=\mathrm{\bar{A}\cdot B+A\cdot B}
   $$

2. 真值表
   $$
   \begin{array}{lll|l}
   \hline \mathrm{A} & \mathrm{B} & \mathrm{C} & \mathrm{F} \\
   \hline 0 & 0 & 0 & 0 \\
   0 & 0 & 1 & 1 \\
   0 & 1 & 0 & 0 \\
   0 & 1 & 1 & 1 \\
   1 & 0 & 0 & 1 \\
   1 & 0 & 1 & 1 \\
   1 & 1 & 0 & 0 \\
   1 & 1 & 1 & 0 \\
   \hline
   \end{array}
   $$

3. 卡诺图

   卡诺图是一种平面方格图，$n$ 个变量的卡诺图由 $2^n$ 个小方格构成，单元格对应的最小项按**格雷码**摆放

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525165010366.png" alt="image-20230525165010366" style="zoom: 80%;" />

   

   

### 逻辑代数的基本定理和规则



- **定理 1（0-1律）**：$0+0=0\quad 1+0=1$ （其他同理。。。）
- **定理 2（重叠律）**：$\mathrm{A+A=A\quad\quad A\cdot A=A}$
- **定理 3（吸收律）**：$\mathrm{A+A\cdot B=A\quad\quad A\cdot (A+B)=A}$
- **定理 4（消除律）**：$\mathrm{A+\bar{A}\cdot B=A+B\quad\quad A\cdot (\bar{A}+B)=A\cdot B}$
- **定理 5（对合律）**：$\mathrm{\bar{\bar{A}}=A}$
- **定理 6（互补律）**：$\mathrm{\overline{A+B}=\bar{A} \cdot \bar{B} \quad\quad \overline{A \cdot B}=\bar{A}+\bar{B}}$
- **定理 7（并项律）**：$\mathrm{A\cdot B +A\cdot \bar{B} =A \quad \quad (A+B)\cdot(A+\bar{B})=A}$
- **定理 8（包含律）**：$\mathrm{A\cdot B+\bar{A}\cdot C+B\cdot C =A\cdot B+\bar{A}\cdot C }$



#### 代入规则

任何一个代入含有变量 $\mathrm{A}$ 的逻辑等式，如果将所有出现 $\mathrm{A}$ 的位置都用同一个逻辑函数 $\mathrm{F}$ 替代，等式仍然成立：

 例如：给定逻辑等式 $\mathrm{A(B+C)=AB+AC}$ 将 $\mathrm{C}$ 都用 $\mathrm{C+D} $代替，得到$\mathrm{A[B+(C+D)]=AB+A(C+D)}$ 仍然成立





#### 反演规则

若将逻辑函数表达式 $F$ 中所有的 “$\cdot$”变成 “+”,“+”变成 “$\cdot$”,“0”变成 “1”,“1”变成 “ 0 ”,原变量变成反变量，反变量变成原变量，并保持原函数中的运算顺序不变，则所得到的新的函数 $\overline{\mathrm{F}}$ 为原函数 $\mathrm{F}$ 的反函数。
$$
\mathrm{F}=\overline{\mathrm{A}} \cdot \mathrm{B}+\mathrm{C} \cdot \overline{\mathrm{D}}\\\overline{\mathrm{F}}=(\mathrm{A}+\overline{\mathrm{B}}) \cdot(\overline{\mathrm{C}}+\mathrm{D})
$$






#### 对偶规则

如果将逻辑函数表达式 $\mathrm{F}$ 中所有的“$\cdot$"变成“+”,“+”变 “$\cdot$”, “0”变成“1”, “1”变成“0”, 并保持原函数中的运算顺序不变, 则所得到的新的逻辑表达式称为函数 $\mathrm{F}$ 的对偶式, 并记作 $\mathrm{ F^\prime}$ 
$$
\mathrm{F}=\mathrm{A} \mathrm{B}+\overline{\mathrm{B}}(\mathrm{C}+\mathrm{0}) \quad \\ \quad \mathrm{F}^{\prime}=(\mathrm{A}+\mathrm{B})(\overline{\mathrm{B}}+\mathrm{C} \cdot \mathrm{1})
$$


### 复合逻辑



用两种及以上的逻辑复合而成的叫做复合逻辑，可以分为以下几类。



1. 与非逻辑
   $$
   \mathrm{F}=\overline{\mathrm{A} \cdot \mathrm{B} \cdot \mathrm{C} \cdots}
   $$
   使用与非门可以实现与、或、非三种基本运算：

   与: $\mathrm{F}=\overline{\overline{\mathrm{A} \cdot \mathrm{B}} \cdot 1}=\overline{\overline{\mathrm{A} \cdot \mathrm{B}}}=\mathrm{A} \cdot \mathrm{B}$

   或: $F=\overline{\overline{\mathrm{A} \cdot 1} \cdot \overline{\mathrm{B} \cdot 1}}=\overline{\overline{\mathrm{A}} \cdot \overline{\mathrm{B}}}=\mathrm{A}+\mathrm{B}$

   非： $\mathrm{F}=\overline{\mathrm{A} \cdot \mathrm{1}}=\overline{\mathrm{A}}$ 

2. 或非逻辑
   $$
   \mathrm{F}=\overline{\mathrm{A}+\mathrm{B}+\mathrm{C}+\cdots}
   $$
   使用或非门可以实现与、或、非三种基本运算：


   与: $\mathrm{F}=\overline{\overline{\mathrm{A}+0}+\overline{\mathrm{B}+0}}=\overline{\overline{\mathrm{A}}+\overline{\mathrm{B}}}=\mathrm{A} \cdot \mathrm{B} $

   或:  $F=\overline{\overline{A+B}+0}=\overline{\overline{A+B}}=\mathrm{A}+\mathrm{B}$ 

   非:  $\mathrm{F}=\overline{\mathrm{A}+0}=\overline{\mathrm{A}}$ 

3. 与或非逻辑
   $$
   \mathrm{F}=\overline{\mathrm{AB}+\mathrm{CD}+\cdots}
   $$

4. 异或逻辑
   $$
   \mathrm{F}=\mathrm{A} \oplus \mathrm{B}=\overline{\mathrm{A}} \mathrm{B}+\mathrm{A} \overline{\mathrm{B}}
   $$

5. 同或逻辑
   $$
   \mathrm{F}=\mathrm{A} \odot \mathrm{B}=\overline{\mathrm{A}} \cdot \overline{\mathrm{B}}+\mathrm{AB}
   $$



### 代数化简法

代数化简法就是运用逻辑代数的公理、定理和规则对逻辑函数进行化简的方法。

以下是常用方法：

1. **并项律**：利用定理7中的 $\mathrm{A} \overline{\mathrm{B}}+\mathrm{AB}=\mathrm{A}$ 消去多余变量
2. **吸收律**：利用定理3中的 $\mathrm{A+AB=A}$ 吸收多余变量
3. **消去律**：利用定理4中的 $A+\bar{A} B=A+B$ 消去多余变量
4. **转换法**：利用定理6中的 $\overline{A+B}=\bar{A} \cdot \bar{B} \quad\quad \overline{A \cdot B}=\bar{A}+\bar{B}$ 转换变量



【例】化简 $F=B C+D+\bar{D} \cdot(\bar{B}+\bar{C}) \cdot(A D+B \bar{C})$
【解】
$$
\begin{aligned}
F & =B C+D+\bar{D} \cdot(\bar{B}+\bar{C}) \cdot(A D+B \bar{C}) \\
& =B C+D+(\bar{B}+\bar{C}) \cdot(A D+B \bar{C}) [消去律]\\
& =B C+D+\overline{B C} \cdot(A D+B \bar{C})[互补律] \\
& =B C+D+A D+B \bar{C}[消去律] \\
& =B+D [吸收律 ,并项律]
\end{aligned}
$$


### 卡诺图化简法

要化简，首先我们要理解什么是 **相邻**

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20190306221517963.png)

我们只考虑取值为1的格子（后简称1格子），从直观上看他们两就是相邻的，不仅如此，以下情况也算相邻

![image-20230525203940467](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525203940467.png)

可能稍微有点难理解，这么远凭什么相邻呢？其实你可以把卡诺图看成卷筒纸中间那个纸筒，把他卷起来就相邻了

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525204136688.png" alt="image-20230525204136688" style="zoom: 50%;" />

接着，你只需要理解一样东西：**相邻的1格子可以合并**。具体合并规则如下：

1. 卡诺图中两个相邻1格的最小项可以合并成一个与项，并消去一个变量。
2. 卡诺图中四个相邻1格的最小项可以合并成一个与项，并消去两个变量。
3. 卡诺图中八个相邻1格的最小项可以合并成一个与项，并消去三个变量。

具体消去哪个变量，要看相邻格子之间是哪个变量在发生变化，消去变化的，留下不变的。

同时，我们还要保持以下原则：

1. 将卡诺图中的1格画圈，一个也不能漏圈，否则最后得到的表达式就会与所给函数不等
2. 1格允许被一个以上的圈所包围。
3. 圈的个数应尽可能得少。即在保证1格一个也不漏圈的前提下，圈的个数越少越好。因为一个圈和一个与项相对应，圈数越少，与或表达式的与项就越少。
4. 按照2k个方格来组合（即圈内的1格数必须为1，2，4，8等），圈的面积越大越好。因为圈越大，可消去的变量就越多，与项中的变量就越少。
5. 每个圈应至少包含一个新的1格，否则这个圈是多余的。
6. 用卡诺图化简所得到的最简与或式不是唯一的。



话不多说，让我们见一道例题。

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525204848278.png" alt="image-20230525204848278" style="zoom:67%;" />

使用下面的方式画圈是不正确的，因为画多了

![image-20230525204935211](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525204935211.png)

因此采取下列画圈方法：

![image-20230525205007333](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525205007333.png)

对于紫色圈：$\mathrm{\bar{A}\bar{B}\bar{C}\bar{D}+\bar{A}\bar{B}{C}\bar{D}=\bar{A}\bar{B}\bar{D}}$ 发现了吗？$\mathrm{C}$ 正是圈中唯一变的量，因此可以消去，类似的，我们可以得到该卡诺图的最简与或式
$$
\mathrm{F=B C+\bar{A} \bar{C} D+\bar{A} \bar{B} \bar{D}}
$$




## 第三章 集成门电路与触发器

### 常用门电路符号及表达式

![image-20230525211145420](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525211145420.png)



### 触发器

触发器是一种时序逻辑电路，是具有记忆功能的电路

> - 时序逻辑电路的功能：任何时刻的稳定输出，不仅与 **该时刻** 的输入有关，还与电路 **原状态** 有关，即与以前的输入有关

触发器具有以下特点：

1. 触发器有两个互补的输出端 $\mathrm{Q}$ 和 $\mathrm{\bar{Q}}$
2. 触发器有两个稳定状态：
   - 输出端 $\mathrm{Q=1、\bar{Q}=0}$ 称为 “1”状态，表示逻辑1
   - 输出端 $\mathrm{Q=0、\bar{Q}=1}$ 称为 “0”状态，表示逻辑0
3. 触发器的两个稳定状态可**相互转换**(称为状态的翻转)。通常把输入信号作用之前的状态称为“现态”，记作 $\mathrm{Q^n}$ 和 $\mathrm{\bar{Q}^n}$ ,把输入信号作用之后的状态称为“次态”，记作 $\mathrm{Q^{n+1}}$ 和 $\mathrm{\bar{Q}^{n+1}}$
4. 输入信号作用后，新状态可长期保持下来，电路具有**记忆功能**（能记忆 1 位二进制数的电路）



#### 与非门构成基本 R-S 触发器

基本R-S触发器，又叫SR锁存器，是构成各种触发器的基本部件，也是最简单的一种触发器。

> 锁存器——不需要触发信号，由输入信号直接完成置 0 或置 1 操作。
> 触发器——需要一个触发信号 ，称为时钟信号 CLOCK ，只有触发信号有效时，才按输入信号完成置 0 或置 1 操作。

基本R-S触发器有两个输入端、两个输出端、两条反馈电路：

![image-20230525212040848](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525212040848.png)



R-S触发器的状态：(输出 $\mathrm{Q}$ 和 $\mathrm{\overline Q}$ 互为相反逻辑，方便工作原理的分析)

-  $\mathrm{Q=1、\bar{Q}=0}$ 称为 “1”状态，表示逻辑1
-  $\mathrm{Q=0、\bar{Q}=1}$ 称为 “0”状态，表示逻辑0



##### 工作原理

输入 $\overline{\mathrm{R}_{\mathrm{D}}}=0, \overline{\mathrm{S}_{\mathrm{D}}}=1$ 时，置 0 每次先从为 0 的输出端开始分析:

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20200418084625991.png)

输入 $\overline{\mathrm{R}_{\mathrm{D}}}=1, \overline{\mathrm{S}_{\mathrm{D}}}=0$ 时，置 1

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215UmVhbGl6YXRpb24=,size_16,color_FFFFFF,t_70.png)

输入 $\overline{\mathrm{R}_{\mathrm{D}}}=1, \overline{\mathrm{S}_{\mathrm{D}}}=1$ 时，保持

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20200418090431333.png)

输入 $\overline{\mathrm{R}_{\mathrm{D}}}=0, \overline{\mathrm{S}_{\mathrm{D}}}=0$ 时，保持

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20200418090606395.png)

注意：当两个输入端由 0 变为 1时，翻转快的门输出变为 0 00 ，另一个不得翻转。因此，该状态为不定状态。




##### 功能描述

状态转移真值表——反映触发器状态变化与输入之间的关系

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20200418095440778.png)

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20200418095600468.png)





##### 次态方程

次态方程可以反映次态 $\mathrm{Q^{n+1}}$ 与现态、输入之间的关系，因为 $\mathrm{R,S} $ 不允许同时为 0，可得：
$$
\mathrm{Q}^{\mathrm{n}+1} =\bar {\mathrm{S}}+\mathrm{R}\cdot \mathrm{Q}
$$

##### 约束方程

因为 $\mathrm{R,S} $ 不允许同时为 0，可得：
$$
\mathrm{S}+\mathrm{R}  =1
$$


#### 或非门构成基本 R-S 触发器

![image-20230525214611031](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525214611031.png)

![image-20230525214639908](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525214639908.png)



##### 次态方程

$$
\begin{aligned}
& \mathrm{Q}^{n+1}=\mathrm{S}+\overline{\mathrm{R}} \mathrm{Q} \\
\end{aligned}
$$

##### 约束方程

$$
 \mathrm{R} \cdot \mathrm{S}=0
$$

#### 钟控控制触发器

在数字系统中，为协调各部分的动作，常常要求某些触发器在 **同一时刻** 动作(即改变状态，也称为翻转)。这就要求有一个同步信号来控 制，这个控制信号叫做**时钟脉冲信号**( clock Pulse，CP)，Clock Pulse 是一串**周期性**的矩形脉冲。



##### 钟控 R-S 触发器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527215742362.png" alt="image-20230527215742362" style="zoom:50%;" />



###### 功能

$$
\begin{array}{cc|c|c}
\hline \mathbf{R} & \mathbf{S} & \mathbf{Q}^{n+1} & \text { 功能说明 } \\
\hline 0 & 0 & \mathbf{Q} & \text { 不变 } \\
0 & 1 & 1 & \text { 置 } 1 \\
1 & 0 & 0 & \text { 置 } 0 \\
1 & 1 & \mathrm{~d} & \text { 不定 } \\
\hline
\end{array}
$$

> 看来R-S触发器是小黑子触发器，为什么呢，看后面就知道了🤣，R-S触发器功能的记忆技巧是：全零不变，全一未知，一正一负看S

###### 次态方程

$$
\begin{aligned}
\mathrm{Q}^{\mathrm{n}+1} & =\mathrm{S}+\overline{\mathrm{R}} \mathrm{Q}^{\mathrm{n}} \\
\end{aligned}
$$

###### 约束方程

$$
\mathrm{RS}  =0
$$



##### 钟控D触发器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526163701055.png" alt="image-20230526163701055" style="zoom: 33%;" />

###### 功能

$$
\begin{array}{c|c|c}
\hline \mathrm{D} & \mathrm{Q}^{n+1} & \begin{array}{l}
\text { 功 能 } \\
\text { 说 明 }
\end{array} \\
\hline 0 & 0 & \text { 置 } 0 \\
1 & 1 & \text { 置 } 1 \\
\hline
\end{array}
$$

###### 状态表

![image-20230527215247119](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527215247119.png)

###### 次态方程

$$
\mathrm{Q}^{n+1}=\mathrm{D}
$$



##### 钟控 J-K 触发器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526163912735.png" alt="image-20230526163912735" style="zoom:33%;" />

###### 功能

在时钟信号（$\mathrm{CP}$） 为 0 时保持不变，在为 1 时有以下功能
$$
\begin{array}{cc|c|c}
\hline \mathrm{J} & \mathrm{K} & \mathrm{Q}^{n+1} & \text { 功能说明 } \\
\hline 0 & 0 & \mathrm{Q} & \text { 不变 } \\
0 & 1 & 0 & \text { 置 } 0 \\
1 & 0 & 1 & \text { 置 1 } \\
1 & 1 & \overline{\mathrm{Q}} & \text { 翻转 } \\
\hline
\end{array}
$$
对于这个功能，记忆技巧是“看 $\mathrm{J} $ 法 ”，全0不变，全1翻转，一正一负看 $\mathrm{J}$ （ $\mathrm{J}$ 是 1  那次态就是 1 ，$\mathrm{J}$ 是 0  那次态就是 0）

厉不厉害你鸡哥

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/4963d9e636d12f2ea8aff5a10ac2d562873568dd.jpg" alt="img" style="zoom: 33%;" />

###### 状态表

![image-20230527212245725](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527212245725.png)

###### 次态方程

$$
\mathrm{Q^{n+1}=J\bar{Q}+\bar{K}Q}
$$



##### 钟控 T 触发器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526164047813.png" alt="image-20230526164047813" style="zoom:33%;" />

###### 功能

$$
\begin{array}{c|c|c}
\hline   \mathbf{T} & \mathbf{Q}^{n+1} & \text { 功能说明 } \\
\hline  
0 & \mathrm{Q} & \text { 不变 } \\
 1 & \mathrm{\bar{Q}} & \text { 翻转 }  \\
\hline
\end{array}
$$



###### 次态方程

$$
\mathrm{Q^{n+1}=T\bar{Q}+\bar{T}Q=T\oplus Q}
$$





##### 触发器的转换

###### R-S转D

将R输入接到S输入的输出上

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527170455602.png" alt="image-20230527170455602" style="zoom: 33%;" />

###### R-S转J-K

将输出的 $\mathrm{Q}$和 $\mathrm{\bar{Q}}$ 反接回输入端中

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527170639769.png" alt="image-20230527170639769" style="zoom:33%;" />



###### J-K转T

将两个输入 $\mathrm{J} $ 和 $\mathrm{K} $ 串起来变成一个输入

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527170807642.png" alt="image-20230527170807642" style="zoom:33%;" />



##### 触发器的触发方式

1. 在电路图标识中，如果一个触发器是边沿触发的，通常会有一个小三角形的符号在触发器的时钟输入端。这个三角形指的是边沿（上升或下降）触发。如果三角形后面还有一个小圆圈，那么这是下降（负）边沿触发；没有圆圈则是上升（正）边沿触发。
2. 在数据表中，它会明确指出触发器的触发方式，包括它是否是边沿触发，以及是上升边沿触发还是下降边沿触发。



## 第四章 组合逻辑电路

> 考纲：
>
> - 电路分析
> - 电路设计
> - 竞争与险象的产生、判断和消除

数字系统中的逻辑电路按其是否具有记忆功能分为**组合逻辑电路**和**时序逻辑电路**两大类型。本章讨论组合逻辑电路，他通常以以下形式出现

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527143611818.png" alt="image-20230527143611818" style="zoom:67%;" />

### 电路分析

所谓电路分析，就是给你一个电路图，然后问你几个问题，比如这个电路实现了什么？能不能画他的波形图之类的，为了能准确分析，我们通常按照下面几个步骤走：

1. **根据逻辑电路图写出输出函数表达式**

   要看懂电路图，首先要明白电路图画了什么：

   ![image-20230525211145420](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230525211145420.png)

   注意分析的时候，**不要一下子全部写出来，要一个一个写，然后最后拼起来**

2. **化简输出函数表达式**

   > 如果你觉得可以硬列的话可以不化简(笑)

3. **列出输出函数真值表**

   

4. **功能评述**



【例】写出组合电路的输出函数及其真值表

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526170911450.png" alt="image-20230526170911450" style="zoom:67%;" />

【解】

1. 根据逻辑电路图写出输出函数表达式

   ![image-20230530130135483](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530130135483.png)
   $$
   \begin{array}{ll}
   \mathrm{P}_1=\overline{\mathrm{A}} & \mathrm{P}_2=\mathrm{B}+\mathrm{C} \\
   \mathrm{P}_3=\overline{\mathrm{BC}} & \mathrm{P}_4=\overline{\mathrm{P}_1 \cdot \mathrm{P}_2}=\overline{\overline{\mathrm{A}}(\mathrm{B}+\mathrm{C})} \\
   \mathrm{P}_5=\overline{\mathrm{A} \cdot \mathrm{P}_3}=\overline{\mathrm{A} \overline{\mathrm{BC}}} & \mathrm{F}=\overline{\mathrm{P}_4 \cdot \mathrm{P}_5}=\overline{\overline{\overline{\mathrm{A}}(\mathrm{B}+\mathrm{C})} \cdot \overline{\mathrm{A} \overline{\mathrm{BC}}}}
   \end{array}
   $$

2. 化简输出函数表达式
   $$
   \begin{aligned}
   \mathrm{F} & =\overline{\overline{\overline{\mathrm{A}}(\mathrm{B}+\mathrm{C})} \cdot \overline{\mathrm{A} \cdot \overline{\mathrm{BC}}}} \\
   & =\overline{\mathrm{A}}(\mathrm{B}+\mathrm{C})+\mathrm{A} \overline{\mathrm{BC}}&&(\overline{A \cdot B}=\bar{A}+\bar{B}) \\
   & =\overline{\mathrm{A}} \mathrm{B}+\overline{\mathrm{A} }\mathrm{C}+\mathrm{A} \overline{\mathrm{B}}+\mathrm{A} \overline{\mathrm{C}}&&(\text{分配律}) \\
   & =\mathrm{A} \oplus \mathrm{B}+\mathrm{A} \oplus \mathrm{C}&&
   \end{aligned}
   $$

3. 画真值表
   $$
   \begin{array}{ccc|c}
   \hline \mathrm{A} & \mathrm{B} & \mathrm{C} & \mathrm{F} \\
   \hline
   0 & 0 & 0 & 0 \\
   0 & 0 & 1 & 1 \\
   0 & 1 & 0 & 1 \\
   0 & 1 & 1 & 1 \\
   1 & 0 & 0 & 1 \\
   1 & 0 & 1 & 1 \\
   1 & 1 & 0 & 1 \\
   1 & 1 & 1 & 0 \\
   \hline
   \end{array}
   $$





### 电路设计

电路设计刚好是反过来的，先画真值表，然后按题目要求用卡诺图推出输出函数

1. **看懂题意，给出逻辑描述**
2. **根据卡诺图求出最简表达式**
3. **根据题意转换逻辑函数**
4. **画出函数逻辑图**



【例】设计一个3变量“多数表决电路”，要求只使用与非门

【解】所谓多数表决，就是少数服从多数，即“两个1以上就输出1”，根据这个思想可以列出真值表
$$
\begin{array}{ccc|c}
\hline \mathrm{A} & \mathrm{B} & \mathrm{C} & \mathrm{F} \\
\hline 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
0 & 1 & 1 & 1 \\
1 & 0 & 0 & 0 \\
1 & 0 & 1 & 1 \\
1 & 1 & 0 & 1 \\
1 & 1 & 1 & 1 \\
\hline
\end{array}
$$
由此可以画出卡诺图

![image-20230526201455239](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526201455239.png)

由此可以列出最简表达式
$$
\mathrm{F=AB+AC+BC}
$$
然后可以对该表达式依据题意转换
$$
F(A, B, C)=\overline{\overline{\mathrm{A B+A C+AC}}}=\overline{\overline{\mathrm{AB}} \cdot \overline{\mathrm{AC}} \cdot \overline{\mathrm{BC}}}
$$
<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526201759051.png" alt="image-20230526201759051" style="zoom:67%;" />





### 险象

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20181124175015453.png" alt="img" style="zoom: 67%;" />

以该图为例，假设此时A是“0”，B是“1”，F应该是0。而某一瞬间A变成了“1”，B变成了“0”，由于A的线比较短，走的比较快，所以很短的时刻内，“A变1”的这个影响很快传到了AND门上，而“B变0”这个影响还没传到AND门上，于是造成了短暂的“F变1”现象，这就是**险象**。在短暂过后，B的影响传了过来，F变回了0

所谓的险象，可以理解为“本来应该是那样，但却有一瞬间反了过来"



#### 判断方法

在一般情况下，我们不考虑线带来的延时问题，一般考虑每个门造成的时间差，即你可能会在题目里看到这种图：

![img](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/20181124180245230.png)

为了判断是否有险象，有两种方法，其中一种方法通常采用以下步骤：

1. 确定考察变量“A”，然后列举其他变量的所有组合
2. 判断每个组合下，考察变量“A”是否以“ $\mathrm{A+\bar{A}} $ ” 或者 " $\mathrm{A\cdot\bar{A}} $" 的形式成双成对出现
3. 如果是，则说明该变量有可能产生现象

> 判断时有个小技巧，如果某个变量 $\mathrm{A}$ 在表达式中本就不同时存在 $\mathrm{A} $ 和 $ \mathrm{\bar{A}} $  那肯定不存在险象

【例】某组合电路的表达式为 $\mathrm{F=\bar{A}\bar{C}+\bar{A}B+AC}$ 判断是否产生现象

1. 考察变量 $\mathrm{A}$
   $$
   \begin{array}{|c c|c|}
   \hline \mathrm{B} & \mathrm{C} & \mathrm{F} \\
   \hline 
   0  &  0  &  \mathrm{F}=\bar{\mathrm{A}} \\
   0  &  1  &  \mathrm{F}={\mathrm{A}} \\
   1  &  0  &  \mathrm{F}=\bar{\mathrm{A}} \\
   1  &  1  &  \mathrm{F}=\mathrm{A}+\bar{\mathrm{A}} \\
   \hline
   \end{array}
   $$
   因此 $\mathrm{A}$ 有可能产生险象

2. 考察变量 $\mathrm{C}$
   $$
   \begin{array}{|c c|c|}
   \hline \mathrm{A} & \mathrm{B} & \mathrm{F} \\
   \hline 
   0  &  0  &  \mathrm{F}=\bar{\mathrm{C}} \\
   0  &  1  &  \mathrm{F}=1 \\
   1  &  0  &  \mathrm{F}={\mathrm{C}} \\
   1  &  1  &  \mathrm{F}={\mathrm{C}} \\
   \hline
   \end{array}
   $$
   因此 $\mathrm{C}$ 不会产生险象



除了逐一判断外，还可以使用卡诺图判断。

卡诺图判断法是看画出来的卡诺圈中是否存在"相切"现象，如果存在，则说明有险象，相切中变的那个变量就是产生险象的变量

【例】判断函数表达式 $\mathrm{F=\bar{A}D+\bar{A}C+AB\bar{C}}$ 是否有险象

【解】存在险象

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526210517539.png" alt="image-20230526210517539" style="zoom:67%;" />

将 $\mathrm{B=D=1,C=0}$ 代入得：$\mathrm{F=\bar{A}+A}$ ，变量 $\mathrm{A}$ 可能产生险象



#### 消除方法

本篇只介绍一个方法：增加冗余项的方法

回到刚才的例子中， 某组合电路的表达式为 $\mathrm{F=\bar{A}\bar{C}+\bar{A}B+AC}$ ，$\mathrm{A}$ 可能产生现象
$$
\begin{array}{|c c|c|}
\hline \mathrm{B} & \mathrm{C} & \mathrm{F} \\
\hline 
0  &  0  &  \mathrm{F}=\bar{\mathrm{A}} \\
0  &  1  &  \mathrm{F}={\mathrm{A}} \\
1  &  0  &  \mathrm{F}=\bar{\mathrm{A}} \\
1  &  1  &  \mathrm{F}=\mathrm{A}+\bar{\mathrm{A}} \\
\hline
\end{array}
$$
所谓险象，就是在$\mathrm{B=C=1}$ 时本来按表达式 $\mathrm{F}=\mathrm{A}+\bar{\mathrm{A}}$ 应该是1才对，但却有一瞬间变成了 "0",因此解决方法就是针对这个情况加一个必然为“1” 的项，于是原式变成了：
$$
\mathrm{F=\bar{A}\bar{C}+\bar{A}B+AC}+\mathrm{BC}
$$


对于卡诺图，要想他不出现“相切”的情况，那就再加一个冗余的卡诺圈：

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230526212007189.png" alt="image-20230526212007189" style="zoom:67%;" />

于是原式 $\mathrm{F=\bar{A}D+\bar{A}C+AB\bar{C}}$ 变成了：
$$
\mathrm{F=\bar{A}D+\bar{A}C+AB\bar{C}+B\bar{C}D}
$$





## 导论 时序逻辑电路

时序逻辑电路的结构通常如下

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527143731228.png" alt="image-20230527143731228" style="zoom: 67%;" />

即稳定输出信号不仅与该电路该时刻的输入信号有关，而且与电路过去的输入信号有关，所谓“与电路过去的输入信号有关” 就是将过去的输入信号存储在“存储电路”中，然后作为输入喂给组合电路。

而存储电路，顾名思义就是有记忆的电路，那什么是有记忆的电路呢？没错，就是[触发器](#触发器)，下文可能会出现各种各样的触发器，因此我把图再放一次方便大家查阅

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527144430065.png" alt="image-20230527144430065" style="zoom:50%;" />

### 电路分类：同步与异步

同步电路是那些由时钟信号驱动的电路。在同步电路中，所有操作都与特定的时钟脉冲同步。这意味着所有的状态变化（例如，存储器中的数据或逻辑门的输出）都是在特定的时钟周期发生的。同步电路的一个主要优点是设计相对简单，因为你只需要考虑特定的时钟周期。然而，同步电路的一个主要缺点是它们通常需要更多的功耗，因为即使电路的一部分没有活动，时钟也会持续工作。

异步电路不依赖于统一的时钟信号来驱动其操作。相反，它们通常使用一种被称为握手的协议，其中一个部分的电路将发送一个信号给另一个部分，告知它何时开始或结束一个操作。这使得异步电路能够在不需要时钟的情况下工作，这可以降低功耗，并允许电路以最大速度运行。然而，异步电路的设计和验证通常比同步电路更复杂，因为你必须考虑所有可能的信号到达和离开的时间。

所以，同步电路和异步电路的主要区别在于它们的操作是否由统一的时钟信号控制。同步电路由时钟驱动，而异步电路则不是。这影响了它们的设计、性能、功耗，以及所需要的设计和验证工作量。



### 电路种类：Mealy与Moore

根据电路的输出是否与输人直接相关,可以分为 **Mealy**（米利）型和 **Moore**（穆尔）型两种不同模型的时序逻辑电路。若时序逻辑电路的输出是电路输入和电路状态的函数,则称为Mealy型时序逻辑电路;若时序逻辑电路的输出仅仅是电路状态的函数,则称为Moore型时序逻辑电路。

![image-20230527151401142](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527151401142.png)

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527151545607.png" alt="image-20230527151545607" style="zoom:67%;" />

### 输入信号的种类：电平与脉冲

在时序逻辑电路中，存在两种常见的类型：电平型（Level-Triggered）和脉冲型（Edge-Triggered）。

1. 电平型(Level-Triggered)：在电平型的触发方式中，设备在时钟信号的整个高电平或低电平阶段都可能会被触发。也就是说，只要时钟信号在一个特定的水平，就可能产生变化。例如，电平型触发器可能在时钟信号的高电平期间响应输入信号的变化。这就意味着在整个高电平期间，只要输入发生变化，触发器就会响应。
2. 脉冲型(Edge-Triggered)：相比之下，脉冲型触发设备只在时钟信号的上升沿或下降沿响应。在其他所有的时间里，设备的状态都保持不变，不会对输入信号的变化做出反应。例如，一个上升沿触发的触发器只在时钟信号从低电平变到高电平的瞬间响应输入信号的变化。

> 在数字电子系统中，**上升沿**和**下降沿**描述的是一个信号状态从低到高（上升沿）或者从高到低（下降沿）的转变。
>
> 1. **上升沿**：当一个数字信号从逻辑低电平跳变到逻辑高电平时，这个跳变的瞬间被称为"上升沿"。这个名字来源于如果你在示波器上观察这个信号，你会看到电压从低电平"上升"到高电平，这个跳变的瞬间就像是一个"沿"。
> 2. **下降沿**：相反地，当一个数字信号从逻辑高电平跳变到逻辑低电平时，这个跳变的瞬间被称为"下降沿"。这也是因为如果你在示波器上观察这个信号，你会看到电压从高电平"下降"到低电平，这个跳变的瞬间看起来就像是一个"沿"。



### 电路的描述方法

- **输出函数表达式**

  对于 Mealy 型电路, 其函数表达式为
  $$
  \mathrm{Z}_i=\mathrm{f}_i\left(\mathrm{x}_1, \cdots, \mathrm{x}_n, \mathrm{y}_1, \cdots, \mathrm{y}_s\right) \quad i=1,2, \cdots, m
  $$
  对于 Moore 型电路, 其函数表达式为
  $$
  \mathrm{Z}_i=\mathrm{f}_i\left(\mathrm{y}_1, \cdots, \mathrm{y}_s\right) \quad i=1,2, \cdots, m
  $$

- **激励函数与激励图**

  激励函数又称为控制函数, 它反映了存储电路（触发器）的输入 $Y$ (组合电路内部输出)与电路输入 $\mathrm{x}$ 和状态 $\mathrm{y}$ 之间的关系。其函数表达式为
  $$
  \mathrm{Y}_j=\mathrm{g}_j\left(\mathrm{x}_1, \cdots, \mathrm{x}_n, \mathrm{y}_1, \cdots, \mathrm{y}_s\right) \quad j=1,2, \cdots, r
  $$
  对于激励函数，还可以画他的激励图

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527152618124.png" alt="image-20230527152618124" style="zoom:67%;" />

  其中“d”表示不确定

- **状态表与状态图**

  状态表反映了触发器在输人作用下现态 $\mathrm{Q^{n}}$ 与次态 $\mathrm{Q^{n+1}}$之间的转移关系

  ![image-20230527153921704](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527153921704.png)

  状态图是一种反映触发器两种状态之间转移关系的有向图，又称为状态转移图，两个圆圈分别代表触发器的两个稳定状态,箭头表示在输入信号作用下状态转移的方向,箭头旁边的标注表示状态转移的条件。

  ![image-20230527154048196](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527154048196.png)

- **时间图**

  时间图其实就是在做实验的时候要交的那张拍下来的图。在时间图里面，CP时钟信号是固定的0101循环，x输入由自己指定，然后根据状态表或者状态图画出来，具体过程在后面的例题会讲解。

  ![image-20230527155601755](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527155601755.png)

  


## 第五章 同步时序逻辑电路



### 电路分析

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527155753517.png" alt="image-20230527155753517" style="zoom: 80%;" />

【例】用表格法分析同步时序逻辑电路。

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527155841077.png" alt="image-20230527155841077" style="zoom:50%;" />

【解】我们先来分析电路：首先要搞清楚存储电路和组合电路分别是哪个，找到输入 $\mathrm{x}$ 和 输出 $\mathrm{Z}$

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527143731228.png" alt="image-20230527143731228" style="zoom: 67%;" />

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527160344975.png" alt="image-20230527160344975" style="zoom:33%;" />

该电路有两个钟控J-K触发器组成存储电路，一个异或门组成组合电路，由于触发器（1）的输出同时作为输入，因此他是一个“**输出是电路状态的电路**”

，即他是一个Moore型电路

![image-20230527161946781](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527161946781.png)

然后我们再来分析激励函数，可以看出，触发器（1）的输入JK都是1
$$
\mathrm{J_1=K_1 =1}
$$
而触发器（2）的JK由异或门决定，异或门的输入为 $\mathrm{x}$ 和触发器（1）的输出 $\mathrm{y_1}$ 
$$
\mathrm{J_2=K_2=x \oplus y_1}
$$
然后我们可以列次态真值表，会改变的量有“输入 $\mathrm{x} $ ”和“现态 $\mathrm{y_1 ,y_2}$” ，同时需要描述每个触发器的输入 $\mathrm{J,K }$ ，最后得到次态 $\mathrm{y_1^{n+1}  ,y_2^{n+1}}$ 
$$
\begin{array}{c|cc|cccc|ccc}
\hline \text { 输入 } & \text { 现 } & \text { 态 } &&{\text { 激励 }}& {\text { 函数 }} &  & \text { 次 }&\text { 态 } \\
\mathrm{x} & \mathrm{y}_2 & \mathrm{y}_1 & \mathrm{~J}_2 & \mathrm{~K}_2 & \mathrm{~J}_1 & \mathrm{~K}_1 & \mathrm{y}_2^{n+1} & \mathrm{y}_1^{n+1} \\
\hline
\end{array}
$$
需要明确的是，输入和现态的可能性是有限的，是可以一次性通过“二进制法”列举出来的
$$
\begin{array}{c|cc|cccc|ccc}
\hline \text { 输入 } & \text { 现 } & \text { 态 } &&{\text { 激励 }}& {\text { 函数 }} &  & \text { 次 }&\text { 态 } \\
\mathrm{x} & \mathrm{y}_2 & \mathrm{y}_1 & \mathrm{~J}_2 & \mathrm{~K}_2 & \mathrm{~J}_1 & \mathrm{~K}_1 & \mathrm{y}_2^{n+1} & \mathrm{y}_1^{n+1} \\
\hline 
0 & 0 & 0  \\
0 & 0 & 1  \\
0 & 1 & 0  \\
0 & 1 & 1  \\
1 & 0 & 0  \\
1 & 0 & 1  \\
1 & 1 & 0  \\
1 & 1 & 1  \\
\hline
\end{array}
$$
然后我们再来填激励函数，根据上面得到的两个公式
$$
\mathrm{J_1=K_1 =1} \\
\mathrm{J_2=K_2=x \oplus y_1}
$$

$$
\begin{array}{c|cc|cccc|ccc}
\hline \text { 输入 } & \text { 现 } & \text { 态 } &&{\text { 激励 }}& {\text { 函数 }} &  & \text { 次 }&\text { 态 } \\
\mathrm{x} & \mathrm{y}_2 & \mathrm{y}_1 & \mathrm{~J}_2 & \mathrm{~K}_2 & \mathrm{~J}_1 & \mathrm{~K}_1 & \mathrm{y}_2^{n+1} & \mathrm{y}_1^{n+1} \\
\hline 
0 & 0 & 0 & 0 & 0 & 1 & 1  \\
0 & 0 & 1 & 1 & 1 & 1 & 1  \\
0 & 1 & 0 & 0 & 0 & 1 & 1  \\
0 & 1 & 1 & 1 & 1 & 1 & 1  \\
1 & 0 & 0 & 1 & 1 & 1 & 1  \\
1 & 0 & 1 & 0 & 0 & 1 & 1  \\
1 & 1 & 0 & 1 & 1 & 1 & 1  \\
1 & 1 & 1 & 0 & 0 & 1 & 1  \\
\hline
\end{array}
$$

还记得鸡哥公式吗？"全0不变，全1翻转，一正一负看鸡哥"，对着这个公式就能写出次态
$$
\begin{array}{c|cc|cccc|ccc}
\hline \text { 输入 } & \text { 现 } & \text { 态 } &&{\text { 激励 }}& {\text { 函数 }} &  & \text { 次 }&\text { 态 } \\
\mathrm{x} & \mathrm{y}_2 & \mathrm{y}_1 & \mathrm{~J}_2 & \mathrm{~K}_2 & \mathrm{~J}_1 & \mathrm{~K}_1 & \mathrm{y}_2^{n+1} & \mathrm{y}_1^{n+1} \\
\hline 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 \\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
0 & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
1 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 \\
1 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\
1 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 1 \\
1 & 1 & 1 & 0 & 0 & 1 & 1 & 1 & 0 \\
\hline
\end{array}
$$
 然后我们就能画状态图了，首先画状态表，状态表的画法是：总的来说是“现态→次态”表，要在表中指明是什么发生变化导致的（这里是 $\mathrm{x}$）
$$
\begin{array}{|cc|cc|cc|}
\hline
现&态  &y_2^{n+1} &y_1^{n+1}&y_2^{n+1}&y_1^{n+1}\\
y_2& y_1 &x=0 &&x=1 \\
\hline 0 & 0 & 0 & 1 & 1 & 1 \\
\hline 0 & 1 & 1 & 0 & 0 & 0 \\
\hline 1 & 0 & 1 & 1 & 0 & 1 \\
\hline 1 & 1 & 0 & 0 & 1 & 0 \\
\hline
\end{array}
$$
再来画状态图

![image-20230527164621609](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527164621609.png)

可以看出，当电路输入 $x=0$ 时, 可逆计数器进行加 1 计数, 其计数序列为

![image-20230527164717545](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527164717545.png)

当输入 $x=1$ 时, 可逆计数器进行减 1 计数, 其计数序列为

![image-20230527164723776](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527164723776.png)

因此该电路实现了一个“二进制可逆计数器”

根据状态图，可以设定输入为$11110000$ 可以画出时间图

![image-20230527165232671](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527165232671.png)

这里有一个细节：CP为0时次态不发生改变（JK触发器的特性），在CP为1后发生改变





【例】分析电路，回答下列问题：

(1) 图⽰电路中采⽤什么触发⽅式； (2) 分析下图所⽰时序逻辑电路，并指出其逻辑功能； (3) 设触发器初态为0，画出在CP脉冲下Q0和Q1的波形。

![image-20230527172257839](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527172257839.png)



【解】老样子，先分析下

![image-20230527195239767](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527195239767.png)

存储电路是两个J-K触发器，而 $\mathrm{J}$ 和 $\mathrm{K}$ 连在一起组成了 $\mathrm{T }$  触发器，从图上看，他是下降沿触发，对两个触发器可以写出激励函数
$$
\begin{aligned}
\mathrm{J_0 =K_0 }&=1 \\
\mathrm{J_0 =K_0 }&=Q_0
\end{aligned}
$$
于是可以作次态真值表
$$
\begin{array}{cc|cccc|ccc}
\hline \text { 现 } & \text { 态 } &&{\text { 激励 }}& {\text { 函数 }} &  & \text { 次 }&\text { 态 } \\
 \mathrm{Q}_0 & \mathrm{Q}_1 & \mathrm{~J}_0 & \mathrm{~K}_0 & \mathrm{~J}_1 & \mathrm{~K}_1 & \mathrm{Q}_0^{n+1} & \mathrm{Q}_1^{n+1} \\
\hline 
 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0  \\
 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1  \\
 1 & 0 & 1 & 1 & 1 & 1 & 0 & 1  \\
 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0  \\
\hline
\end{array}
$$
由于没有输入变量，所以这个也能当状态图看

![image-20230527201010125](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527201010125.png)

所以这实现了一个四进制的加计数器（00→01→10→11→00）

所谓下边沿就是只有在时钟信号由1转0的瞬间才会改变电路状态

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527201203816.png" alt="image-20230527201203816" style="zoom:67%;" />



### 电路设计

电路设计跟分析刚好反过来的

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527203057965.png" alt="image-20230527203057965" style="zoom:67%;" />

要注意以下几个点：

- 状态表要化到最简，才能知道触发器到底要存几个状态
- 根据存几个状态确定要多少个触发器（比如4个状态就是2个，6个状态就是3个，因为 $6<2^3$ ）



【例】用 J-K 触发器作为存储元件, 设计一个 “ 101 ” 序列检测器。该电路有一个输人 $\mathrm{x}$ 和一个输出 $Z$, 当随机输人信号中出现 “101 ”序列时, 输出一个 1 信号。典型输人/输出序列如下。
$$
\begin{array}{lllllllllllll}
\text { 输入 } \mathrm{x} & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 0 \\
\text { 输出 } \mathrm{Z} & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0
\end{array}
$$
【解】首先要确定触发器要存几个状态：假设第一个是A状态，输入0没反应，输入1就到了B，B状态要存1，C状态存10，D状态要存“101”同时输出1，这样看来一共要存4个状态，也就是两个触发器。接下来想办法画状态图。这里要借用数据结构与算法中，字符串的模式匹配KMP算法的思想（书本211页）

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527210642963.png" alt="image-20230527210642963" style="zoom: 33%;" />

在A状态下，如果输入1则匹配成功，进入B，如果不成功，则保持A状态

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527210938915.png" alt="image-20230527210938915" style="zoom:50%;" />

在B状态下，如果输入1则匹配不成功，理应要回A，但1又是A匹配成功的情况，所以保持B状态（这就是改进思想），

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527211000868.png" alt="image-20230527211000868" style="zoom:50%;" />

在C状态下，输入1则匹配成功，否则回到A状态

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527211052118.png" alt="image-20230527211052118" style="zoom:50%;" />

在D状态下，输出一个1，如果再输入1，理应要回A，但1又是A匹配成功的情况，所以直接跳B状态，否则回到A

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527211145986.png" alt="image-20230527211145986" style="zoom:50%;" />

于是得到了状态图，接着我们要用状态图来写二进制真值表，首先要确定一个编码方案，这个就随便写了（因为目前没有理想的公式能概括）

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527211252146.png" alt="image-20230527211252146" style="zoom:50%;" />

对着编码方案和状态图，就可以写二进制真值表

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527211337811.png" alt="image-20230527211337811" style="zoom:50%;" />

然后确定我们到底用什么触发器，看个人选择了，这里选择J-K触发器，下面是触发器的状态表

![image-20230527212245725](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527212245725.png)



对着触发器的状态表就能对着写次态真值表

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527212434316.png" alt="image-20230527212434316" style="zoom:50%;" />

这里举个例子，以A状态为例，考察第一个触发器 $\mathrm{y_1}$ 由于他从0变1 有两种情况，要么是 $\mathrm{JK=11}$ 要么是 $\mathrm{JK=10}$ 所以不能确定到底是什么，所以填"d"

为了要确定到底画什么样的电路图，就要确定 $\mathrm{J,K}$ 的函数怎么写，所以要全部列出来，在激励函数中“d”的取值既然可以任意，那就想要什么就要什么，反过来说，就是不考虑“d”的取值，只考虑确定的情况

- 确定 $\mathrm{J_1}$：先不看“d”，把其他的都看一看 ，你会发现 $\mathrm{J_1}$ 居然可以全部等于输入 $\mathrm{x}$ 于是可以得到
  $$
  \mathrm{J_1 = x}
  $$

- 确定 $\mathrm{K _1}$：先不看“d”，把其他的都看一看 ，你会发现 $\mathrm{K_1}$ 居然全部跟输入 $\mathrm{x}$ 相反，于是可以得到
  $$
  \mathrm{K_1 = \bar{x}}
  $$

- 确定 $\mathrm{J_2}$：先不看“d”，把其他的都看一看 ，发现除了$\mathrm{x=0,y_1=1}$ 的情况下，$\mathrm{J_2=1}$ 以外，其他均为0，于是可以得到
  $$
  \mathrm{J_2=\bar{x}y_1}
  $$

- 确定 $\mathrm{K_2}$：先不看“d”，把其他的都看一看 ，同 $\mathrm{J_2}$ ，可以得到
  $$
  \mathrm{K_2=\bar{x}\bar{y_1}+x\bar{y_1}=\bar{x}\oplus y_1}
  $$

- 确定 $\mathrm{Z}$：这里是输出，所以要关注 $\mathrm{y_1,y_2}$ 同理可以得到
  $$
  \mathrm{Z=y_1y_2}
  $$

至此我们可以知道如何画电路图了：对于输入 $\mathrm{x}$ 加个非门，两条线分别导触发器（1），触发器（1）引条线跟加过非门的 $\mathrm{x}$ 到触发器（2）的 $\mathrm{J}$ 线，同时再引条线跟加过非门的 $\mathrm{x}$ 组个异或门到触发器（2）的 $\mathrm{K}$ 线，最后对两个触发器的输出接一个与门到输出

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230527214447390.png" alt="image-20230527214447390" style="zoom:50%;" />



## 第六章 异步时序逻辑电路

> 大纲：
>
> - 电路的**分析**（只考分析不考设计）

异步时序逻辑电路的工作特点是：电路中没有统一的时钟脉冲信号同步，电路状态的改变是外部输入信号变化直接作用的结果；在状态转移过程中，各存储元件的状态变化不一定发生在同一时刻，不同状态的维持时间不一定相同，并且可能出现非稳定状态

根据电路结构模型和输入信号形式的不同，异步时序逻辑电路可分为**脉冲异步时序逻辑电路**和**电平异步时序逻辑电路**



### 脉冲异步时序逻辑电路

脉冲异步时序逻辑电路的存储电路由触发器组成（可以是时钟控制触发器或者非时钟控制触发器），电路输入信号为脉冲信号。

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528131209046.png" alt="image-20230528131209046" style="zoom:50%;" />

> 在异步时序逻辑电路中，脉冲信号通常是指一种具有特定持续时间和幅度的短暂信号。这种信号通常由一个快速的上升边缘（也称为正边缘或前沿）和一个稍慢的下降边缘（也称为负边缘或后沿）组成。

#### 电路分析

跟同步时序逻辑是相同的：

1. 写出电路的输出函数和激励函数表达式;
2. 列出电路次态真值表或次态方程组;
3. 作出状态表和状态图;
4. 画出时间图并用文字描述电路的逻辑功能。

要注意以下几个点：

- 因为异步时序逻辑电路没有统一的时钟脉冲信号同步，所以触发器的时钟控制端也要当激励函数处理（具体体现在画真值表的时候要考虑时钟控制端 $\mathrm{C}$ )
- 不允许出现两个及以上的脉冲，换句话说就是不用考虑这么多情况，假设有3个输入 $\mathrm{x_1,x_2,x_3}$ 则只需要考虑 $001,010,100$ 三种情况，其他都不用考虑



【例】分析该电路

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528132138827.png" alt="image-20230528132138827" style="zoom:50%;" />

【解】粗略看一下电路大概长这样

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528132352141.png" alt="image-20230528132352141" style="zoom:50%;" />

根据这个可以写出激励函数表达式
$$
\begin{array}{ll}
\mathrm{Z}=\mathrm{xy}_2 \mathrm{y}_1 & \\
\mathrm{~J}_2=\mathrm{K}_2=1 & \mathrm{C}_2=\mathrm{y}_1 \\
\mathrm{~J}_1=\mathrm{K}_1=1 & \mathrm{C}_1=\mathrm{x}
\end{array}
$$
接着我们来写次态真值表，前面说过，我们要考虑到时钟信号，因为在触发器中，当信号（$\mathrm{CP}$） 为0时，触发器保持原状态不变。因此我们不需要考虑输入 $\mathrm{x=0}$ 的情况

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528133329831.png" alt="image-20230528133329831" style="zoom:50%;" />

接着来填写激励函数，要注意的是，因为 $\mathrm{C}_2=\mathrm{y}_1$ 会出现触发器（2）不通电的情况，所以 $\mathrm{C_2}$ 可以留空，而 $\mathrm{C_1}$ 需要填一个向下箭头的符号，因为在图中可以知道，该触发器是一个下降沿触发方式

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528133511596.png" alt="image-20230528133511596" style="zoom:50%;" />

状态表就写出来了

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528133613577.png" alt="image-20230528133613577" style="zoom:50%;" />

状态图也能画出来

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528133627783.png" alt="image-20230528133627783" style="zoom:50%;" />



对于时间图，有一些要注意的地方：输入 $\mathrm{x}$ 是你自己定的，怎么喜欢怎么来，但为了画图方便，你可以把脉冲间隔画长一点，毕竟脉冲短了就没地方画了

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528133844042.png" alt="image-20230528133844042" style="zoom:50%;" />

要注意画出时钟信号和对齐触发时间

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528134132971.png" alt="image-20230528134132971" style="zoom:50%;" />

这里的触发器是下降沿触发，所以在脉冲下降沿的时候指一个箭头到触发器（1），同样的触发器（1）的下降沿要引起触发器（2）的变化





### 电平异步时序逻辑电路

所谓电平信号，其实指的是持续时间不规律的脉冲

这是脉冲信号

![image-20230528134544774](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528134544774.png)

这是电平信号

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528134743352.png" alt="image-20230528134743352" style="zoom: 67%;" />

电平异步时序逻辑电路一般长这样

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528134832868.png" alt="image-20230528134832868" style="zoom: 67%;" />

可以看到，存储电路由延迟元件组成（可能是专用的延迟元件或者利用电路本身固有的延迟），终于不用触发器啦🤩



电平异步时序逻辑电路对输入信号有一定要求：

1. 不允许两个及以上信号同时变化，这个跟脉冲时序逻辑是一样的

2. 必须等内部变化结束变稳定状态（下称稳态）时才允许输入信号发生变化，不然才刚变一半被你打断了，那这个电路就爆了

   ![image-20230530103603362](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530103603362.png)



由于没有了触发器，所以描述方法从真值表变成了流程表，从状态图变成了总态图

流程表：

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528143916544.png" alt="image-20230528143916544" style="zoom:67%;" />

在流程表中需要对稳态进行特别标注，其实就是给他画个圈圈

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528144001327.png" alt="image-20230528144001327" style="zoom: 80%;" />

怎么读这个流程表呢，

1. 假设RS=10，状态为0，这时候从读表可知下一状态为1，于是就垂直往下跳到稳态

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528144305886.png" alt="image-20230528144305886" style="zoom:80%;" />

2. 假设RS=11，状态为0，如果要从该总态到下一总态，方法是令RS=10

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528144544645.png" alt="image-20230528144544645" style="zoom:80%;" />

于是可以得出结论：稳态和稳态之间只能通过水平再垂直跳转，也就是说，不是所有的稳态之间都能转换，详细见下面的总态图



总态图：

总态的表达方式是”(输入变量X，激励状态Y)/输出Z“，以上面的R-S触发器为例，他的总态图长这样

![image-20230528144131695](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528144131695.png)

不同总态之间不一定是双向通的，比如(01,0)/0 与 (11,1)/1 在流程图中，可以找到一条线路从 (11,1)/1 到 (01,0)/0 但找不到一条路能从 (01,0)/0到 (11,1)/1

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528144814171.png" alt="image-20230528144814171" style="zoom:80%;" />



#### 电路分析

电平异步时序逻辑电路的分析过程如下：

1. 写出输出函数和激励函数表达式
2. 作流程表
3. 画总态图或时间图
4. 说明功能



【例】分析电路

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528144938732.png" alt="image-20230528144938732" style="zoom:67%;" />

【解】粗略看一眼该电路

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528145333361.png" alt="image-20230528145333361" style="zoom:67%;" />

可以写出输出函数和激励表达式
$$
\begin{aligned}
& \mathrm{Z=y_2y_1}\\
& \mathrm{Y_2=x_2 x_1 y_2+x_2 \bar{x}_1 \bar{y}_1}  \\
& \mathrm{Y_1=x_2 y_1+x_1}
\end{aligned}
$$
可以作流程表，方式是二次状态和输入按照**格雷码**的顺序排列，因为不允许一下子变两个

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528145726012.png" alt="image-20230528145726012" style="zoom:67%;" />

总态图就出来了

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528145950510.png" alt="image-20230528145950510" style="zoom:67%;" />

其实在这里就能看出来到底在干什么了，你可以从输出“1”这里开始看，然后反过来推

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528150109941.png" alt="image-20230528150109941" style="zoom:67%;" />

蓝色框是一个大循环，来回转换，这种一般没有什么意义，可以看到红色部分，一旦从00 到了 10  再到11 就能输出一个1，说明这是一个“00→10→11”序列检测器

这时候就有疑问了，凭什么是“00→10→11” 我说“01→00→10→11” 和“10→11” 不行吗？ 这就涉及到"最小公因数"的思想了，这个问题可以转化成：

判断句子中是否有“吃饭”这个词

1）今天我去吃饭了→有

2）昨天我没有吃饭→有

3）后天会有人送饭→无

在这个例子中，显然不能用“去吃饭了”来判断到底有没有“吃饭”，因为这样第二个就判断不出来了，同样也不能以“饭”来判断，不然第三个就是了。因此这个序列一定要保证**足够简短的同时又有效**，回到刚才的例子中，只有“(00,00)/0”条件下才有可能走通到输出“1”，而(01,01)/0 和“(10,01)/0” 都能走，故他们不能作为判断序列



为了例题的完整性，给出时间图的画法，首先要写出相应序列

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528151028007.png" alt="image-20230528151028007" style="zoom:67%;" />

然后你要凸显这个**时间延迟** 也就是说你要画出中间过渡态（打*号的地方），然后你要等过渡完了才能输入下一个状态

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528151114183.png" alt="image-20230528151114183" style="zoom:67%;" />

下面我们来解读这个时间图，为了凸显这个**时间延迟**，我们假设跳两次总态的时间为 $\Delta t$ ,为什么是两次呢 ，因为从一个总态到另一个总态刚好只能跳两次，详见总态的介绍。

从 $t_0$ 到 $t_1$ ，即输入从 $00$ 到 $10$ ，要发生 $(00,00)→(10,00)→(10,10)$ 的变化，所以在变化的瞬间，$y_2,y_1$ 不会立即变化，而是在 $\Delta t $ 的时间段后从 $00→10$

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530105317948.png" alt="image-20230530105317948" style="zoom: 67%;" />

从 $t_1$ 到 $t_2$ ，即输入从 $10$ 到 $11$ ，要发生 $(10,10)→(11,10)→(11,11)$ 的变化，所以在变化的瞬间，$y_2,y_1$ 不会立即变化，而是在 $\Delta t $ 的时间段后从 $10→11$

![image-20230530105605560](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530105605560.png)



## 第七章 中规模通用集成电路及其应用

> 大纲：
>
> - 常用电路：二进制并行加法器、译码器、编码器、多路选择器、电路分配器、双时针4位二进制同步可逆计数器**74193**及转换成模小于16的计数器（书上例题）、集成定时器555的三个应用多谐振荡器
>
> (中规模时序电路只考74193 注意：1.异步清零 存储  暂态过渡 D是高位 2.其他转换 任意进制的计数器)
>
> （组合逻辑中规模：加法器（超前进位  全加器串行 ） 74138译码器 带优先级的编码器74142？ 数据选择器 数据分配器  要注意主线：函数发生器）
>
> 三个 35电路？？ 



### 中规模组合逻辑电路

#### 加法器

##### 串行进位二进制并行加法器

考虑二位加法
$$
0\space1\longrightarrow1\space0
$$
在这个过程中，个位向十位发送了“进1”的信号，由此十位进了1，这就是串行加法的原理

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528162647189.png" alt="image-20230528162647189" style="zoom: 50%;" />

##### 超前进位二进制并行加法器

在串行加法器中，4位的计算必须等3位的进位标志才能计算，而3位的又需要2位，2位要等1位，这样非常慢，所以考虑涉及一个能四个位并行计算的加法器。

设计这种加法器的思想是把每一位的加法全展开然后化简，首先先列出第 $i$ 位的加法表达式
$$
\begin{aligned}
& C_i=\overline{A_i} B_i C_{i-1}+A_i \overline{B_i} C_{i-1}+A_i B_i \overline{C_{i-1}}+A_i B_i C_{i-1} \\
& =\left(A_i \oplus B_i\right) C_{i-1}+A_i B_i
\end{aligned}
$$
这个表达式分别列举了四种情况，考虑了加数和被加数在有无进位标志下，输出函数的值，在化简合并后，把这两部分拆成进位产生函数和进位传递函数
$$
\begin{array}{ll}
\mathrm{A}_{\mathrm{i}} \oplus \mathrm{B}_{\mathrm{i}} \rightarrow \mathrm{P}_{\mathrm{i}} & \text { （进位传递函数） } \\
\mathrm{A}_{\mathrm{i}} \mathrm{B}_{\mathrm{i}} \rightarrow \mathrm{G}_{\mathrm{i}} & \text { （进位产生函数） }
\end{array}
$$
于是
$$
C_i=P_i C_{i-1}+G_i
$$
考虑4位并行运算，则可以列出四位的输出函数表达式
$$
\begin{aligned}
& \mathrm{C}_1=\mathrm{P}_1 \mathrm{C}_0+\mathrm{G}_1 \\
& \mathrm{C}_2=\mathrm{P}_2 \mathrm{C}_1+\mathrm{G}_2=\mathrm{P}_2 \mathrm{P}_1 \mathrm{C}_0+\mathrm{P}_2 \mathrm{G}_1+\mathrm{G}_2 \\
& \mathrm{C}_3=\mathrm{P}_3 \mathrm{C}_2+\mathrm{G}_3=\mathrm{P}_3 \mathrm{P}_2 \mathrm{P}_1 \mathrm{C}_0+\mathrm{P}_3 \mathrm{P}_2 \mathrm{G}_1+\mathrm{P}_3 \mathrm{G}_2+\mathrm{G}_3 \\
& \mathrm{C}_4=\mathrm{P}_4 \mathrm{C}_3+\mathrm{G}_4=\mathrm{P}_4 \mathrm{P}_3 \mathrm{P}_2 \mathrm{P}_1 \mathrm{C}_0+\mathrm{P}_4 \mathrm{P}_3 \mathrm{P}_2 \mathrm{G}_1+\mathrm{P}_4 \mathrm{P}_3 \mathrm{G}_2+\mathrm{P}_4 \mathrm{G}_3+\mathrm{G}_4
\end{aligned}
$$
将其全部展开，会发现虽然说 $\mathrm{C_4}$ 虽然由 $\mathrm{C_3}$ 得出，但因为 $\mathrm{C_3}$ 是可展开的，同时 $\mathrm{C_2}$ 和 $\mathrm{C_1}$ 也是可展开的，也就是说，只需要知道 $\mathrm{A_i,B_i,C_0}$ 就能一次性把四位全部算出来，我觉得这是一种进步

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528163553730.png" alt="image-20230528163553730" style="zoom:80%;" />

但其实说了那么多并没有什么卵用，我只是那么一说，考试不会让你列数学原理的。



##### 芯片改造

最常用的4位并行加法器是74283芯片

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528164027355.png" alt="image-20230528164027355" style="zoom: 50%;" />

加法器一般规范 $\mathrm{A}$ 为被加数， $\mathrm{B}$ 为加数， $\mathrm{F}$ 为输出



【例】设计一个8421码转余3码的代码转换电路

【解】余3码是由8421码加3形成的代码，所以直接在被加数里面加“0011” 就完事了

![image-20230528164352873](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528164352873.png)





#### 译码器

译码器是一个能将 $n$ 个输入变量变换成 $2^n$ 个变量的多输出组合电路，比如实现 $(110)_2\longrightarrow(6)_{10}$ 的译码器长这样

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528164840886.png" alt="image-20230528164840886" style="zoom: 80%;" />

其中A为输入端，Y为输出端，比如输入$(0100)$ 会输出 $(000 001 000)$ 代表6

上面的译码器只是为了引入这个概念，了解了解就行，考试不考，考试考的是74138芯片，

![image-20230528165028176](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528165028176.png)

 74138型3-8线译码器有三个使能端，分别是G1、G2A和G2B。这三个使能端的作用是控制译码器的工作状态。当这三个使能端的电平满足特定条件时，译码器才会工作。

1. S1（使能端1）：这是一个高电平有效的使能端。也就是说，当G1为高电平（1）时，译码器才会工作。如果G1为低电平（0），则译码器不工作。
2. S2和S3（使能端2和3）：这两个使能端都是低电平有效。也就是说，当S2和S3都为低电平（0）时，译码器才会工作。如果S2或S3中任何一个为高电平（1），则译码器不工作。

通过给使能端通电可以自由的开关译码器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528165724542.png" alt="image-20230528165724542" style="zoom: 67%;" />

##### 芯片改造

【例】使用74138和与非门实现全减器

【解】要解本题，思路跟加法是一样的，减法是本质全减器是处理某一位的结果，然后再拼在一起（串行or并行），但本题重点不是让你怎么拼，而是问你怎么设计某一位的全减器

首先我们要理解某一位减法是怎么实现的，先从十进制开始说，假设你在计算这个式子：

![image-20230528171907162](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528171907162.png)

如果数不够减，那就要借位，所以如果要计算某一位的减法，你至少需要三个东西：被减数A，减数B，是否被借位，刚好74138就是3位输入

同时我们要处理输出，原式的输出是8位，结果（二进制下的输入的值）是多少，对应位的值就是0，那我们得到的结果肯定不能是这个，我们期望的结果应该是两个，一个是结果 $\mathrm{D}$ 一个是是否要借上一位 $\mathrm{G_i}$ ，在不知道怎么画电路的时候可以先写出真值表

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528172130176.png" alt="image-20230528172130176" style="zoom:67%;" />

根据真值表可以写出 $\mathrm{D_i,G_i}$ 的表达式，然后根据与非门的要求进行转换
$$
\begin{aligned}
& D_i\left(A_i, B_i, G_{i-1}\right)=\mathrm{m}_1+\mathrm{m}_2+\mathrm{m}_4+\mathrm{m}_7=\overline{\overline{\mathrm{m}}_1 \cdot \overline{\mathrm{m}}_2 \cdot \overline{\mathrm{m}}_4 \cdot \overline{\mathrm{m}}_7} \\
& \mathrm{G}_i\left(\mathrm{~A}_i, \mathrm{~B}_i, \mathrm{G}_{i-1}\right)=\mathrm{m}_1+\mathrm{m}_2+\mathrm{m}_3+\mathrm{m}_7=\overline{\overline{\mathrm{m}}_1 \cdot \overline{\mathrm{m}}_2 \cdot \overline{\mathrm{m}}_3 \cdot \overline{\mathrm{m}}_7}
\end{aligned}
$$
由于74138的输出天然带“非门”，所以只需要把它们穿在一起穿一个与非门就行了

![image-20230528172619120](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528172619120.png)







#### 编码器

编码器就是译码器反过来，多变1，这里不再给出示例，但介绍一个新东西：优先编码器74148

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530131711322.png" alt="image-20230530131711322" style="zoom:80%;" />

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530131732471.png" alt="image-20230530131732471" style="zoom:67%;" />

让我们来详细认识一下这个编码器： $\mathrm{\overline{I_s}}$ 是一个选通输入，当他置1时代表整个编码器无效（其实就是开关），所谓优先，意思就是数字越大的越优先，即在 $\mathrm{\overline{I_0} -\overline{I_7}}$ 中，$\overline{I_7}$ 的优先级最高，谁先置0，输出结果就是什么，例如，当 $\mathrm{\overline{I_5}} =0$ 而其他都为1时，结果是 $010$ ,注意这里输出的不是 $\mathrm{I}$ 的下标5，而是优先级3



【例】输出为 $\bar{Y}_2, \bar{Y}_1, \bar{Y}_0$ 。当使能输入 $\bar{S}=0$, 编入为 $\bar{I}_1=\bar{I}_5=\bar{I}_6=0$, 其余编码输入全为 1 时, 则输出 $\bar{Y}_2 \bar{Y}_1 \bar{Y}_0$ 应为？

【解】 $\bar{I}_6=0, \bar{I}_6$ 的优先级最高, $\therefore \overline{Y_2} \bar{Y}_1 \overline{Y_0}=001$



#### 多路选择器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528173401986.png" alt="image-20230528173401986" style="zoom:80%;" />

选择器就是，你输入了一些数据 $\mathrm{D}$ 然后你告诉我哪一个（$\mathrm{A}$）要输出，我就输出哪一个

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528173453651.png" alt="image-20230528173453651" style="zoom: 80%;" />

#### 多路分配器

![image-20230528173619870](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528173619870.png)

分配器就是，你输入一个数据 $\mathrm{D}$ 然后你告诉我你要分给谁（$\mathrm{A}$）我就分给谁（$\mathrm{f}$）

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528173711456.png" alt="image-20230528173711456" style="zoom:67%;" />





### 中规模时序逻辑电路

数字系统中最典型的时序逻辑电路是计数器和寄存器。这些在第四第五章都有设计，这里我们只讲一个74193芯片

74193芯片是一个异步清零的同步计数器

> 异步清零（Asynchronous Clear）是一种电子电路的功能，特别是在数字逻辑电路和计数器中。在SN74LS193这种四位二进制可逆计数器中，异步清零功能允许用户在任何时候立即将计数器的输出清零，而不需要等待下一个时钟脉冲。
>
> 这个功能被称为“异步”，是因为它不需要与时钟信号同步。只要清零输入被激活（在SN74LS193中，这是通过将CLEAR输入拉低来实现的），计数器的输出就会立即清零，无论时钟信号的状态如何。

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528184034625.png" alt="image-20230528184034625" style="zoom:80%;" />



<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528185000674.png" alt="image-20230528185000674" style="zoom: 50%;" />

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528185654521.png" alt="image-20230528185654521" style="zoom:80%;" />

当 $\mathrm{CLR}$ 置为1时，不管发生什么，直接清零， $\mathrm{\bar{LD}}$ 置0表示要预设值，此时会把ABCD输入的值作为内部存储的值，置1表示要进行计数，此时如果 $\mathrm{CP_D}$ 置1表示累加计数，此时如果往 $\mathrm{CP_D}$ 输入一个脉冲，内部就会进行一次累加，累减同理



#### 74193转其他模的计数器

##### 构成模10加法计数器

首先我们要明确初值和最大值是多少。初值可以设置为 $0000$ ，对于模10来说，最多能有0—9 ，10个数，因此在 $1001$的时候，如果再进1，会变成 $1010$ ，此时要直接调用CLR归零，实现方法是用一个与门接到 $\mathrm{Q_B,Q_D} $ 上

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528190442634.png" alt="image-20230528190442634" style="zoom: 50%;" />

##### 构成模12减法计数器

如果是减法，则永远不需要归零，所以CLR接地，可以自己选一个大于12的初值，这里可以选择 $1111$ 作为初值，如果减到了“0”，说明如过到了 $0100$ 再减一，到了 $0011$ 这时候必然在前两位均为0，因此可以用 $\mathrm{Q_C,Q_D}$ 接一个与门跟初始脉冲接个与门连 $\mathrm{\overline{LD}}$ 上，初始脉冲就是有一个低电平的脉冲，因为 $\mathrm{\overline{LD}}$ 为0时代表设初值

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528190913597.png" alt="image-20230528190913597" style="zoom: 50%;" />





##### 构成模256的加法计数器

256刚好是16的两倍，可以用两个计数器实现，当计数器（1）满16时，计数器（2）进一，实现方法是用一个非门接输出的 $\overline{\mathrm{Q}}_{\mathrm{CB}}$ 上，当进一时会发出一个向上的脉冲，刚好传给 $\mathrm{CP_D}$ 

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528191159138.png" alt="image-20230528191159138" style="zoom:50%;" />



##### 构成模147的计数器

同样适用两个计数器实现，方法同"构成模12减法计数器" ，我们要确定到底是什么状态的时候满147然后归零，因此要写出147的二进制
$$
(147)_{10}=(10010011)_2
$$
然后只需要判断对应位上同时为1即可，用与门实现

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528191455080.png" alt="image-20230528191455080" style="zoom:50%;" />

#### 知识迁移

考试还真不一定会给你一块74193芯片，他可能会给你一块新的芯片，再告诉你他的功能，让你设计，其实道理是一样的

【例】试用四位二进制加计数器74161构成十进制计数器，用反馈清零法。

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528192057893.png" alt="image-20230528192057893" style="zoom: 67%;" />

先分析这块板，累加结果是 $\mathrm{Q}$ 用 $\mathrm{ABCD}$ 设置初值，但本题不需要设置初值，所以不用管，然后来看使能端，我们需要用到的是计数功能和清零功能，而清零功能对使能端没有要求，所以直接通一个恒1的信号就行，再来看时钟是上边沿触发，所以给一个正常的CP信号就行，最后看怎么清零

初始是 $0000$ 最大值是1001（9），一旦到了1010（10） 就要归0，所以在 $\mathrm{Q_A,Q_C}$ 加一个与门，一旦这个成立了就给 $\mathrm{R_D}$ 置零，一开始恒1，要给他置0，那就拿个非门，最终用与非门来完成这个需求

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528192658584.png" alt="image-20230528192658584" style="zoom:50%;" />











### 中规模信号产生与变换电路

本篇只介绍5G555集成定时器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528210459174.png" alt="image-20230528210459174" style="zoom: 33%;" />

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528205643677.png" alt="image-20230528205643677" style="zoom: 33%;" />

如果不想了解具体的工作原理，只需要知道以下几点即可：

- 1脚接地，8脚接电源，4脚大部分情况下也接电源
- 5脚通过一个0.01μF电容接地，也可以悬空（不建议）
- 2、6、7脚根据不同应用有不同接法
- 3脚是输出

> 想到一个记忆技巧，"D"是电，所以是放电端（雾） 

#### 应用1 多谐振荡器

所谓的“稳态”指的是3脚输出端的电平高低是否稳定。“无稳态”的意思是，3脚的输出会自动在高低之间变换，而不会稳定地停留在高或低上。这就形成了一个振荡器。这个特性可以用来制作LED的闪烁效果、电子琴等，也可以用于PWM技术控制电动机的转速等。

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528212315773.png" alt="image-20230528212315773" style="zoom: 33%;" />

这个电路的工作原理如下：

1. 接通电源瞬间，因为电容不能突变，所以 $\mathrm{\overline{TH}}$ 电压小于 $\frac{2}{3}V_{CC}$ , $\mathrm{\overline{TR}}$ 电压小于 $\frac{1}{3}V_{CC}$ ，对比功能表，$\mathrm{OUT} $ 为1
2. 电容电压升高到 $\frac{2}{3}V_{CC}$ 时，$\mathrm{\overline{TH}}$ 和 $\mathrm{\overline{TR}}$ 电压为 $\frac{2}{3}V_{CC}$ ，对比功能表，$\mathrm{OUT} $ 为0
3. $\mathrm{OUT} $ 为0后，放电三极管导通，电容开始放电
4. 电容电压下降到 $\frac{1}{3}V_{CC}$ 时，恰好又符合 $\mathrm{\overline{TH}}$ 电压小于 $\frac{2}{3}V_{CC}$ , $\mathrm{\overline{TR}}$ 电压小于 $\frac{1}{3}V_{CC}$ ，对比功能表，$\mathrm{OUT} $ 为1
5. 于是开始2-4循环



因此我们可以得出以下公式：

- 充电时间 $t_H=0.7 \cdot (R_1+R_2 ) \cdot C_1$
- 放电时间 $L_2=0.7 \cdot R_2 \cdot C_1$
- 周期 $T_w=t_1+t_2=0.7 \cdot\left(R_1+2R_2\right) \cdot C_1$
- 频率 $f=\frac{1}{T}=\frac{1.43}{\left(R_1+2R_2\right) \cdot C_1}$
- 占空比 $\frac{t_1}{T}=\frac{R_1+R_2}{R_1+2R_2}$



【例】分析下图电路，画出Vc、Vo 电压波形，计算Vo高电平持续的时间Th

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528212625267.png" alt="image-20230528212625267" style="zoom:80%;" />

【解】
$$
t_H=0.7 \cdot (R_1+R_2 ) \cdot C
$$
<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528212730723.png" alt="image-20230528212730723" style="zoom: 33%;" />

> 这是2021年原题。。。



#### 应用2 施密特触发器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528213857354.png" alt="image-20230528213857354" style="zoom:50%;" />

图中, $v_1$ 上升时的阈值电压 $V_{\mathrm{T}+}$ 称为**正向阈值电平或上限触发电平**; 下降时的阈值电压 $V_{\mathrm{T}}$ - 称为**负向阈值电平或下限触发电平**。它们之间的差值称为**回差电压** (或滞后电压), 用 $\Delta V_{\mathrm{T}}$ 表示, 即
$$
\Delta V_{\mathrm{T}}=V_{\mathrm{T}+}-V_{\mathrm{T}-}\mathrm{=\frac{1}{3}V_{CC}}
$$
施密特触发器的应用广泛,其典型应用有波形变换、脉冲整形、幅值鉴别等。

- **波形变换**:施密特触发器能将正弦波、三角波或任意形状的模拟信号波形变换成矩形波。

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528214125845.png" alt="image-20230528214125845" style="zoom:50%;" />

- **脉冲整形**:经传输后的矩形脉冲往往由于干扰及传输线路的分布电容等因素而使信号发生畸变,出现前、后沿变坏或信号电平波形.上叠加脉动干扰波等现象。用施密特触发器,选择适当的回差电压OVτ,即可对输人信号整形后输出。

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528214145149.png" alt="image-20230528214145149" style="zoom: 50%;" />

- **幅值鉴别**:施密特触发器能在一系列幅值各异的脉冲信号中鉴别出幅值大于VT+的脉冲,并产生对应的输出信号。

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528214158608.png" alt="image-20230528214158608" style="zoom:50%;" />



#### 应用3 单稳态触发器

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528214446926.png" alt="image-20230528214446926" style="zoom:50%;" />

通过调节定时元件$R、C$ 的参数，即可改变输出脉冲的宽度 $t_w$
$$
t_w \approx 1.1 R C
$$



## 考试指南

这里列举一下常见的大题，供大家参考



### 函数发生器

函数发生器指的是用中规模组合电路实现某个逻辑函数的功能，通常使用**74138译码器**和**选择器**。通常出的题型有以下情况：

1. 实现逻辑函数的功能
   $$
   \mathrm{F(A,B,C)=\sum m(3,6,7)}
   $$

2. 实现逻辑函数 $\mathrm{L=AB+BC}$

这两种情况本质上都在问一个东西，就是当输入 $\mathrm{A,B,C}$ 时应该什么时候输出1，什么时候输出0，通过电路来实现这一功能

#### 74138译码器

该译码器在输出门上具有最强大的非门，配合与非门可以实现逻辑函数

【例】用3线-8线译码器74138 (可附加与非门)实现组合逻辑函数L=AB+BC, 要求画出电路图: (10分) 

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528193327403.png" alt="image-20230528193327403" style="zoom:67%;" />

【解】先大概看一下他给的板，下面那个使能端跟书本上的不太一样，但道理不变的，他那两个绑在一起的已经提前给了非门了，所以三个端绑一起接个恒1信号就行，然后看看题目，他要实现的逻辑函数有三个参数，刚好对应三条线，因此我们要画真值表

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528194112068.png" alt="image-20230528194112068" style="zoom:50%;" />

可以看到，只有 $\mathrm{m_3,m_6,m_7}$ 会输出1，题目要求用与非门，那刚好这个与非门就能实现了原因是
$$
\mathrm{Z_i(A_i,B_i,C_i)=m_3+m_6+m_7=\overline{\overline{m_3+m_6+m_7}}=\overline{\overline{m_3}\cdot\overline{m_6}\cdot\overline{m_7}}}
$$
而 $\mathrm{Y}$ 输出天然带个非，所以一个与非门就搞定了

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528194655914.png" alt="image-20230528194655914" style="zoom:67%;" />



#### 选择器

选择器是一个由 $n$ 个选择输入， $2^n$ 个数据输入，1个输出的电路，输出的结果取决于选择输入和输入

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230528173453651.png" alt="image-20230528173453651" style="zoom: 80%;" />

换句话说，你可以控制输出的是哪一位的 $\mathrm{D}$ ，也可以控制输出的 $\mathrm{D}$ 是0还是1。由此，我们可以写出选择器的函数表达式，这对于我们解决问题很关键：
$$
\begin{aligned}
Y= & \overline{\mathrm{A}}_2 \overline{\mathrm{A}}_1 \overline{\mathrm{A}}_0 \mathrm{D}_0+\overline{\mathrm{A}}_2 \overline{\mathrm{A}}_1 \mathrm{~A}_0 \mathrm{D}_1+\overline{\mathrm{A}}_2 \mathrm{~A}_1 \overline{\mathrm{A}}_0 \mathrm{D}_2+\overline{\mathrm{A}}_2 \mathrm{~A}_1 \mathrm{~A}_0 \mathrm{D}_3 \\
& +\mathrm{A}_2 \overline{\mathrm{A}}_1 \overline{\mathrm{A}}_0 \mathrm{D}_4+\mathrm{A}_2 \bar{A}_1 \mathrm{~A}_0 \mathrm{D}_5+\mathrm{A}_2 \mathrm{~A}_1 \overline{\mathrm{A}}_0 \mathrm{D}_6+\mathrm{A}_2 \mathrm{~A}_1 \mathrm{~A}_0 \mathrm{D}_7
\end{aligned}
$$
这个表达式很好解释，以前两个为例， $\overline{\mathrm{A}}_2 \overline{\mathrm{A}}_1 \overline{\mathrm{A}}_0 \mathrm{D}_0$ 指的是，当选择输入为 $(000)$ 时，输出 $\mathrm{D_0}$， $\overline{\mathrm{A}}_2 \overline{\mathrm{A}}_1 {\mathrm{A}}_0 \mathrm{D}_1$ 指的是，当选择输入为 $(001)$ 时，输出 $\mathrm{D_1}$，其实这就是选择器的数学表达式，根据这个，可以将选择器改造成函数发生器，根据改造的种类可以分为以下三种

- $m=n$ （用n个数据输入来实现 $m$ 的变量的函数）

  设计这种电路跟译码器是神似的，甚至真值表都不用画

  【例】用8路MUX实现以下逻辑功能
  $$
  \mathrm{F(A,B,C)=\sum m (2,3,5,6)}
  $$
  【解】这里指的是输出对应的 $\mathrm{D_2,D_3,D_3,D_6}$ 时要为1，其余为0，那意思就是给这4个D恒1信号，其他恒0信号

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230529134824820.png" alt="image-20230529134824820" style="zoom:67%;" />

- $m=n+1$ （用n个数据输入来实现 $m$ 的变量的函数）

  【例】用4路MUX实现以下逻辑功能
  $$
  \mathrm{F(A,B,C)=\sum m (2,3,5,6)}
  $$
  【解】4路MUX最多允许两个 $\mathrm{A}$ 输入，也就是说，$\mathrm{C}$是多余的（悲），这个时候就要把逻辑功能全展开，并按照选择器的输出函数那样按照二进制序进行排序

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230529135338774.png" alt="image-20230529135338774" style="zoom: 50%;" />

  在排列后，发现 $\mathrm{C}$ 是可以充当输入 $\mathrm{D}$ 的功能的，于是就可以按照上述方式输入

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230529135437805.png" alt="image-20230529135437805" style="zoom:50%;" />

- $m≥n+2$ （用n个数据输入来实现 $m$ 的变量的函数）

  【例】用4路MUX实现4变量逻辑函数的功能,函数表达式为
  $$
  \mathrm{F}(\mathrm{A}, \mathrm{B}, \mathrm{C}, \mathrm{D})=\sum \mathrm{m}(0,2,3,7,8,9,10,13)
  $$
  【解】思路是一样的，将函数表达式全展开，然后按你的想法， 你觉得把哪些变量作为选择输入，就按照二进制序排列哪些变量
  $$
  \begin{aligned}
  & \mathrm{F}(\mathrm{A}, \mathrm{B}, \mathrm{C}, \mathrm{D})=\sum \mathrm{m}(0,2,3,7,8,9,10,13) \\
  & =\overline{\mathrm{A}} \overline{\mathrm{B}} \overline{\mathrm{C}} \overline{\mathrm{D}}+\overline{\mathrm{A}} \overline{\mathrm{B}} \mathrm{C} \overline{\mathrm{D}}+\overline{\mathrm{A}} \overline{\mathrm{B} C D}+\overline{\mathrm{ABCD}}+\mathrm{A} \overline{\mathrm{B}} \overline{\mathrm{C}} \overline{\mathrm{D}}+\mathrm{A} \overline{\mathrm{B}} \overline{\mathrm{C}} \mathrm{D}+\mathrm{A} \overline{\mathrm{B}} \mathrm{C} \overline{\mathrm{D}}+\mathrm{AB} \overline{\mathrm{C}} \mathrm{D} \\
  & =\overline{\mathrm{A}} \overline{\mathrm{B}}(\overline{\mathrm{C}} \overline{\mathrm{D}}+\mathrm{C} \overline{\mathrm{D}}+\mathrm{CD})+\overline{\mathrm{A}} \mathrm{B} \cdot \mathrm{CD}+\mathrm{A} \overline{\mathrm{B}}(\overline{\mathrm{C}} \overline{\mathrm{D}}+\overline{\mathrm{C}} \mathrm{D}+\mathrm{C} \overline{\mathrm{D}})+\mathrm{AB} \cdot \overline{\mathrm{C}} \mathrm{D} \\
  & =\overline{\mathrm{A}} \overline{\mathrm{B}}(\mathrm{C}+\overline{\mathrm{D}})+\overline{\mathrm{A}} \mathrm{B} \cdot \mathrm{CD}+\mathrm{A} \overline{\mathrm{B}}(\overline{\mathrm{C}}+\overline{\mathrm{D}})+\mathrm{AB} \cdot \overline{\mathrm{C}} \mathrm{D} \\
  &
  \end{aligned}
  $$
  根据变换后的逻辑表达式, 即可确定各数据输人 $\mathrm{D}_i$ 分别为
  $$
  \mathrm{D}_0=\mathrm{C}+\overline{\mathrm{D}} \quad \mathrm{D}_1=\mathrm{CD} \quad \mathrm{D}_2=\overline{\mathrm{C}}+\overline{\mathrm{D}}=+\overline{\mathrm{CD}} \quad \mathrm{D}_3=\overline{\mathrm{CD}}
  $$
  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230529140026451.png" alt="image-20230529140026451" style="zoom: 50%;" />

  $$
  \begin{aligned}
  \mathrm{F}(\mathrm{A}, \mathrm{B}, \mathrm{C}, \mathrm{D}) & =\sum \mathrm{m}(0,2,3,7,8,9,10,13) \\
  & =\overline{\mathrm{A}} \overline{\mathrm{B}} \overline{\mathrm{C}} \overline{\mathrm{D}}+\overline{\mathrm{A}} \overline{\mathrm{B}} \mathrm{C} \overline{\mathrm{D}}+\overline{\mathrm{A}} \overline{\mathrm{B}} \mathrm{CD}+\overline{\mathrm{A} B C D}+\mathrm{A} \overline{\mathrm{B}} \overline{\mathrm{C}} \overline{\mathrm{D}}+\mathrm{A} \overline{\mathrm{B}} \overline{\mathrm{C}} \mathrm{D}+\mathrm{A} \overline{\mathrm{B} C} \overline{\mathrm{D}}+\mathrm{AB} \overline{\mathrm{C}} \mathrm{D} \\
  & =\overline{\mathrm{C}} \overline{\mathrm{D}}(\overline{\mathrm{A}} \overline{\mathrm{B}}+\mathrm{A} \overline{\mathrm{B}})+\overline{\mathrm{C}} \mathrm{D}(\mathrm{A} \overline{\mathrm{B}}+\mathrm{AB})+C \overline{\mathrm{D}}(\overline{\mathrm{A}} \overline{\mathrm{B}}+\mathrm{A} \overline{\mathrm{B}})+\mathrm{CD}(\overline{\mathrm{A}} \overline{\mathrm{B}}+\overline{\mathrm{A}} \mathrm{B}) \\
  & =\overline{\mathrm{C}} \overline{\mathrm{D}} \cdot \overline{\mathrm{B}}+\overline{\mathrm{C}} \mathrm{D} \cdot \mathrm{A}+\mathrm{C} \overline{\mathrm{D}} \cdot \overline{\mathrm{B}}+\mathrm{CD} \cdot \overline{\mathrm{A}}
  \end{aligned}
  $$

  根据变换后的逻辑表达式, 可确定各数据输人 $D_i$ 分别为

  $$
  \mathrm{D}_0=\overline{\mathrm{B}} \quad \mathrm{D}_1=\mathrm{A} \quad \mathrm{D}_2=\overline{\mathrm{B}} \quad \mathrm{D}_3=\overline{\mathrm{A}}
  $$

  <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230529140101180.png" alt="image-20230529140101180" style="zoom:50%;" />



### 化简

#### 暴力化

- **定理 3（吸收律）**：$\mathrm{A+A\cdot B=A\quad\quad A\cdot (A+B)=A}$
- **定理 4（消除律）**：$\mathrm{A+\bar{A}\cdot B=A+B\quad\quad A\cdot (\bar{A}+B)=A\cdot B}$
- **定理 5（对合律）**：$\mathrm{\bar{\bar{A}}=A}$
- **定理 6（互补律）**：$\overline{A+B}=\bar{A} \cdot \bar{B} \quad\quad \overline{A \cdot B}=\bar{A}+\bar{B}$
- **定理 7（并项律）**：$\mathrm{A\cdot B +A\cdot \bar{B} =A \quad \quad (A+B)\cdot(A+\bar{B})=A}$
- **定理 8（包含律）**：$\mathrm{A\cdot B+\bar{A}\cdot C+B\cdot C =A\cdot B+\bar{A}\cdot C }$

【例】化简 $F=A D+A \bar{D}+A B+\bar{A} C+B D+A C E G+\bar{B} E G+D E G H$

【解】
$$
\begin{aligned}
F&=A D+A \bar{D}+A B+\bar{A} C+B D+A C E G+\bar{B} E G+D E G H \\
&= A+A B+\bar{A} C+B D+A C E G+\bar{B} E G+D E G H \\
&= A+A B+ C+B D+A C E G+\bar{B} E G+D E G H \\
&= A+ C+B D+A C E G+\bar{B} E G+D E G H\\
&= A+ C+B D+\bar{B} E G+D E G H\\
\end{aligned}
$$




#### 卡诺图化

【例】卡诺图法求函数 $F=A B \bar{D}+\bar{A} D+\bar{A} B \bar{C}+A C \bar{D}$ 的最简与或式

【解】

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230529144900584.png" alt="image-20230529144900584" style="zoom:33%;" />

$$
F=\bar{A}D+B\bar{C}\bar{D}+AC\bar{D}
$$





### 触发器大全

![image-20230530142821389](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230530142821389.png)





## 参考文章

- [【 FPGA 】组合逻辑中的竞争与险象问题（一）_李锐博恩的博客-CSDN博客](https://blog.csdn.net/Reborn_Lee/article/details/84450786?ops_request_misc=&request_id=&biz_id=&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~koosearch~default-7-84450786-null-null.268^v1^koosearch&utm_term=险象&spm=1018.2226.3001.4450)

- [卡诺图化简法_Samplay的博客-CSDN博客](https://blog.csdn.net/hahasusu/article/details/88244155?ops_request_misc=%7B%22request%5Fid%22%3A%22168508966316800192266937%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=168508966316800192266937&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88244155-null-null.142^v88^insert_down38v5,239^v2^insert_chatgpt&utm_term=卡诺图&spm=1018.2226.3001.4187)

- [求只因头像【蔡徐坤表情包吧】_百度贴吧 (baidu.com)](https://tieba.baidu.com/p/8102680686)

- [555定时器介绍_Risehuxyc的博客-CSDN博客](https://blog.csdn.net/huxyc/article/details/124919997?ops_request_misc=%7B%22request%5Fid%22%3A%22168527768716800225591253%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=168527768716800225591253&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124919997-null-null.142^v88^insert_down38v5,239^v2^insert_chatgpt&utm_term=555定时器&spm=1018.2226.3001.4187)
