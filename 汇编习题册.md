# 习题册

<p align="right"><i><font color=#0000FF> ——made by njtech_计2104 Melody</font></i></p>

## 考纲

考试题型涉及：选择题、简答题、程序分析题、程序设计题

- 第一部分：字符的表示方法、汇编语言源程序与汇编语言
- 第二部分：物理地址、段地址、段内地址和逻辑地址、标志寄存器、段寄存器(CS、 DS、SS、ES)
- 第三部分：寄存器间接寻址方式、数据传送指令、基址变址寻址方式、算术运算指令、逻辑操作指令、有效地址传送指令（LEA）、算术运算指令、寻址方式
- 第四部分：变量、数值回送操作符、重复定义操作符(DUP)、属性操作符、 常量
- 第五部分：条件转移指令、比较指令CMP、比较指令、循环控制指令
- 第六部分：子程序的编程原则、参数的传递、子程序的调用与返回指令
- 第七部分：宏与子程序的区别、宏内局部标号定义伪指令、重复汇编、条件汇编
- 第八部分： I/O指令、 设置中断向量获取中断向量、 中断向量表、中断过程、键盘IO程序设计
- 其它部分：Debug指令



## 第一部分

【例】设机器字长为8位，使用二进制补码的方式计算下列各题，运算结果分别用十六进制和十进制表示：

（1）34-65	（2）-20+33	（3）-45-45

【解】我们首先需要将十进制数转换为二进制补码。对于8位二进制补码：

1. 非负数的二进制补码与其原码相同。
2. 负数的二进制补码是其对应正数的二进制补码（原码）取反并加一。

（1）对于 34-65：

1. 34 的二进制补码是 00100010
2. -65 的二进制补码是 10111111
将这两个数相加：
```
  00100010
+ 10111111
---------
  11100001
```
在十进制下，这个补码代表-31（补码反转后加一得到原码，再用十进制表示）。
在十六进制下，这个补码是 -1F。



（2）对于 -20+33：

1. -20 的二进制补码是 11101100
2. 33 的二进制补码是 00100001
将这两个数相加：
```
  11101100
+ 00100001
---------
  00001101
```
在十进制下，这个补码代表13（补码反转后加一得到原码，再用十进制表示）。
在十六进制下，这个补码是 -0D。

（3）对于 -45-45：

1. -45 的二进制补码是 11010011
2. 另一个 -45 的二进制补码是 11010011
将这两个数相加：
```
  11010011
+ 11010011
---------
 110100110
```
结果超出了8位，所以需要进位，忽略最左边的1位后得到：
```
  10100110
```
在十进制下，这个补码代表-90（补码反转后加一得到原码，再用十进制表示）。
在十六进制下，这个补码是 -5A。

所以，34-65的结果是-31（十进制）或者-1F（十六进制），-20+33的结果是13（十进制）或者0D（十六进制），-45-45的结果是-86（十进制）或者-5A（十六进制）。



## 第二部分

1. 在实模式下，段地址和偏移地址为3017: 000A的存储单元的物理地址为( )
   A.3017BH		B.30170H		C.3017AH		D.30210H

【答案】C

【解析】物理地址计算公式为：段地址 x 16 + 偏移地址



## 第三部分

1. 指令MOV AX，[SI+2000H]的寻址方式为 ( )。
   A.基址寻址	B.寄存器间接寻址	C.变址寻址	D.直接寻址

【答案】C

【解析】这题中的指令是 `MOV AX，[SI+2000H]`，在x86汇编语言中，这是一种变址寻址方式。"变址寻址"的特点是，其地址由一个基址寄存器的内容和一个偏移量相加组成，这样可以动态地改变操作数的地址。在本题中，`SI`是基址寄存器，`2000H`是偏移量，二者相加得到最终的地址。因此，本题的答案选择C，即变址寻址。

> ppt中这叫相对寻址，但其他都不对只能选这个了。。。



2. 若栈顶的物理地址为20100H， 当执行完指令 `POP AX` 后，栈顶的物理地址为
   A.20098H		B.20102H		C.200FEH		D.20100H

【答案】B

【解析】在x86架构中，栈是向低地址增长的，也就是说，当我们添加（PUSH）一个项目到栈上时，栈顶地址会减小；当我们从栈上移除（POP）一个项目时，栈顶地址会增大。

对于本题，`POP AX`这条指令将从栈中弹出一个字（word，两个字节）并将其放入AX寄存器中。在这个过程中，栈顶地址会增加2个字节。因此，如果栈顶的物理地址在执行指令之前为20100H，那么执行完 `POP AX` 指令后，栈顶的物理地址就变为20102H。



3. 执行下列指令后AL寄存器中的值是()
   ```assembly
   MOV	 AL,0BFH
   TEST AL,0FCH
   ```

   A.0BCH		B.0ACH		C.0DCH		D.0BFH

【答案】D

【解析】在x86汇编语言中，`TEST`指令用于进行位测试。它对两个操作数进行位与（AND）操作，但不会保存结果，仅用于更新标志寄存器（FLAGS）。

在这个问题中，首先执行 `MOV AL,0BFH` 将立即数0BFH（二进制表示为1011 1111）加载到AL寄存器中。然后执行 `TEST AL,0FCH`（0FCH的二进制表示为1111 1100）对AL寄存器和立即数0FCH进行位与操作。

但是 `TEST` 指令并不会改变AL寄存器中的值，因此执行上述两条指令后，AL寄存器中的值仍为初始值0BFH。



## 第四部分

1. 已知DX=0B9H, 则指令SHR DX,1 执行后，DX中的值为( )。
   A.00B9H		B.005CH		C.05CBH		D.00DCH

【答案】B

【解析】在x86汇编语言中，`SHR `是逻辑右移指令。这个指令将指定的目标数值向右移动指定的位数，并将最右侧的位丢弃。同时，左侧空出的位将被填充为0。

在这个问题中，指令 `SHR DX,1` 将寄存器DX中的值向右移动1位。已知DX的初始值为0B9H（在二进制中为10111001）。当我们将这个值右移1位后，得到的值是01011100，转换为十六进制即为5C。所以执行完 `SHR DX,1` 指令后，DX中的值变为005CH。



## 第五部分

1. 已知(DS) =2000H,(BX)=1256H,(SI)=528FH,则执行指令 `JMP BX` 后，IP寄存器的内容是()。
   A.1256H		B.2000H		C.3256H		D.528FH

【答案】A

【解析】在x86汇编语言中，`JMP`是跳转指令。对于`JMP BX`这条指令，CPU将会把BX寄存器的内容复制到IP寄存器中，从而使程序跳转到BX所指定的地址去执行。

在这个问题中，已知BX寄存器的值为1256H，所以执行`JMP BX`指令后，IP寄存器的内容就会被改变为1256H。



## 第七部分

1. 列表伪操作.XALL的含义是( ) 
   A.列出 包括注释在内的所有宏展开		B.只列出产生目标码的宏展开
   C.不列出任何展开信息							D.以上说法都不正确

【答案】B

【解析】在汇编语言中，.XALL是一个控制宏展开列表的伪操作。其含义是只列出产生目标码的宏展开。当一个宏被调用时，汇编程序会将宏定义中的代码展开，而不是实际调用宏。而.XALL伪操作的作用是在程序列表中只显示实际产生了目标码的宏展开，对于不产生目标码的部分则不会展示。



## 第八部分

1. 在80X86微机的输入输出指令中，I/O 端口号通常是由DX寄存器提供的，但有时也可以在指令中直接指定端口号，可以直接由指令指定的I/O端口数为()
   A.65535		B.65536		C.255		D.256

【答案】D

【解析】在x86架构中，我们可以使用IN和OUT指令来从I/O端口读取数据或向I/O端口写入数据。在这些指令中，端口号通常由DX寄存器提供，但也可以在指令中直接提供。

当端口号在指令中直接提供时，它是一个8位的立即数，因此其最大值为255（在二进制表示中，一个8位的数可以表示的最大值为11111111，即255）。但是，由于我们通常从0开始计数，因此实际上有256个可以由指令直接指定的I/O端口。

因此，这个问题的答案是D.256。



2. INT21H在中断向量表中的地址是()
   A.84H		B.83H		C.82H		D.88H

【答案】A

【解析】在x86架构中，每个中断向量在中断向量表中的地址都是固定的，且每个向量占用4字节。中断向量表从内存地址0000:0000开始，因此，一个特定的中断n的向量地址计算公式是4*n。

对于这个问题，INT 21H的向量地址是4 * 21H = 84H。请注意，这里的计算是在16进制中完成的，所以乘以4等价于左移两位。

因此，这个问题的答案是A.84H。

## 其他部分

1. 在DEBUG工具中，显示寄存器内容的命令是( )。
   A. G	B. D	C.T	D.R.

【答案】D

【解析】-r（Register）：这个指令可以让你查看和修改寄存器的值。



## 分析程序题

1. 执行下列指令后，AX寄存器中的内容是什么?

   ```assembly
   MOV CL,3
   MOV AX,0D8H
   ROL AX,1
   ROR AX,CL
   ```

【答案】 0036H

【解析】首先，我们需要理解指令`ROL`和`ROR`。

`ROL` 是Rotate Left，向左旋转指令。`ROL AX,1` 指令将会把寄存器AX中的值向左旋转一位，也就是最左边的位会被复制到最右边，其余各位都向左移动一位。

`ROR` 是Rotate Right，向右旋转指令。`ROR AX,CL`指令将会把寄存器AX中的值向右旋转CL个位，也就是最右边的位会被复制到最左边，其余各位都向右移动CL位。

在这个程序中，我们首先将3放入CL，将0D8H（即1101 1000）放入AX，然后执行`ROL AX,1`，使AX变为1B0H（即1101 1000 << 1 =  1011 0001 ）。然后执行`ROR AX,CL`，将AX向右旋转3位，得到036H（即 1011 0001 >> 3 =  0011 0110）。





2. 假设程序中的数据定义如下:
   ```assembly
   PARTNO DW  0
   PNAME  DB  16 DUP(0)
   COUNT  DD  ?
   PLENTH EQU $-PARTNO
   ```

   问PLENTH的值是多少?

【答案】0016H

【解析】这段程序中使用了汇编语言中的数据定义和标签。

`DW`、`DB`和`DD`分别表示定义一个字（word，16位）、字节（byte，8位）和双字（double word，32位）。

`PARTNO DW 0`定义了一个字，所以占用2个字节。

`PNAME  DB  16 DUP(0)`定义了16个字节，所以占用16个字节。

`COUNT  DD  ?` 在这里占用4个子节，但不初始化，具有预留位置的作用。

`EQU`是汇编语言中的等号，用于定义常量。`$`表示当前的程序计数器值（也就是目前的地址），而`PARTNO`就是一个标签，表示PARTNO那个字的地址。

因此，`PLENTH EQU $-PARTNO`表示PLENTH的值等于当前地址减去PARTNO的地址。这其实就是计算从PARTNO开始到当前位置所占用的字节总数。

由于PARTNO占用2个字节，PNAME占用16个字节，COUNT占用4个子节，所以PLENTH的值就是2 + 16 + 4  = 22，换算成十六进制就是16H。



3. 假设程序中的数据定义如下:
   ```assembly
   LNAME  DB 50 DUP (0)
   CODE_LIST DB 1,2,3,4,5
   ```

   (1)用一条指令将LNAME的偏移地址放入BX寄存器中。
   (2)用一条指令将CODE_ LIST的头两个字节的内容放入DI寄存器中。

【答案】 (1) MOV BX, OFFSET LNAME  或者 LEA BX,  LNAME .	(2)	MOV  DI,  WORD  PTR  CODE_LIST

【解析】在x86汇编语言中，`MOV`指令用于传送数据，`OFFSET`操作符用于获取一个标签的偏移地址，`WORD PTR`用于指定一个操作数的大小为一个字。

(1) `MOV BX, OFFSET LNAME`或`LEA BX, LNAME`都可以将LNAME的偏移地址放入BX寄存器中。这两个指令都可以完成同样的工作，但`LEA`（Load Effective Address，加载有效地址）指令通常在计算某个内存位置的地址时使用。

(2) `MOV DI, WORD PTR CODE_LIST`指令将CODE_LIST的头两个字节的内容（即一个字）放入DI寄存器中。在这里，我们假设处理器处于实模式（即每个段内的所有偏移地址都可以直接访问）。这个指令会首先把CODE_LIST的第一个字节（1）和第二个字节（2）组合成一个字（在小端模式下，低字节在前，高字节在后，因此得到的字是0201H），然后把这个字放入DI寄存器中。



4. 画图说明下列语句所分配的存储空间及初始化的数据值。

   ```assembly
   WORD_VAR DW 2 DUP(1,2), 56H,'0K' ,'TE’, 1FFH . 
   ```

   其中0，K，T，E的ASCII码分别为: 4FH, 4BH, 54H, 45H

【答案】01 00 02 00 01 00 02 00 56 00 4B 4F 45 54 FF 01

【解析】在x86汇编语言中，DW表示定义字（Define Word），用于定义一个16位（2字节）的数据。DUP是重复（DUPlicate）操作符，用于初始化一个数据项的多个副本。

首先，`2 DUP(1,2)`会生成2个副本的1和2，每个数为一个字（16位），在内存中的表示为：01 00 02 00 01 00 02 00 （小端序，低字节在前，高字节在后）。

然后，`56H`是一个字，其内存中的表示为：56 00。

接下来，`'0K'`是一个字，'0'和'K'的ASCII码分别为4FH和4BH，所以其在内存中的表示为：4B 4F（小端序）。

接着，`'TE'`也是一个字，'T'和'E'的ASCII码分别为54H和45H，所以其在内存中的表示为：45 54（小端序）。

最后，`1FFH`是一个字，其在内存中的表示为：FF 01。

综上，这条语句所分配的存储空间及初始化的数据值为：01 00 02 00 01 00 02 00 56 00 4B 4F 45 54 FF 01。





5. 给定宏定义如下：
   ```assembly
   FOOD MACRO P1， P2， P3
       MOV AX,P1
       P2 P3
   ENDM
   ```

   请展开宏调用: FOOD VAR， DEC， BX

【答案】

```assembly
1	MOV	AX,	VAR
1	DEC	BX
```

【解析】在汇编语言中，宏（MACRO）是一种用于代替一段指令序列的工具。宏定义（MACRO...ENDM）中的每一个标识符P1、P2、P3都是一个参数，它们在宏调用时会被替换为实际的参数值。

在这个例子中，宏`FOOD`定义了三个参数：P1，P2，P3。宏的主体包含两条指令：`MOV AX,P1`和`P2 P3`。当调用宏`FOOD`时，实际参数`VAR`、`DEC`、`BX`将分别替换P1、P2、P3。

因此，当宏调用`FOOD VAR， DEC， BX`被展开时，会生成以下指令：

```assembly
MOV AX, VAR
DEC BX
```

这两行指令分别将VAR的值移入寄存器AX，以及将BX寄存器的值递减。



6. 宏定义如下:
   ```assembly
   INT21 MACRO FUNCTN
       MOV AH, FUNCTN
       INT 21H
   ENDM
   DISP MACRO CHAR
       MOV DL, CHAR
       INT21 02H
   ENDM
   ```

   试展开宏调用: DISP 'A'

【答案】

```assembly
1	MOV	DL,	‘A'
2	MOV	AH,	02H
2	INT	21H
```

【解析】在这个例子中，我们有两个宏定义，`INT21`和`DISP`。

宏`INT21`有一个参数`FUNCTN`，它的主体包含了两条指令：`MOV AH, FUNCTN`和`INT 21H`。当宏`INT21`被调用时，`FUNCTN`会被替换为实际的参数值。

宏`DISP`也有一个参数`CHAR`，它的主体包含了两条指令：`MOV DL, CHAR`和`INT21 02H`。在这里，`INT21 02H`其实是另一个宏调用，它调用了宏`INT21`并将`02H`作为参数传递。

所以，当宏调用`DISP 'A'`被展开时，会生成以下指令：

```assembly
MOV DL, 'A'
MOV AH, 02H
INT 21H
```

这些指令分别将字符'A'的ASCII码值移入DL寄存器，然后调用21H中断进行输出操作。



7. 给定(SP) =0110, (SS)=0330, (FLAGS)=1240, 以下存储单元的内容为(00050)=0140，(00052) =0104，在段地址为0802及偏移地址为01A2 的单元中有一条中
   断指令INT 14H，紧接其后的一条指令其段地址为0802偏移地址为01A4，试问执行INT 14H指令后，SP, SS, CS, IP, FLAGS的内容是什么?栈项的三个字是什么? (标志寄存器各标志对应位如下图所示)

   ![image-20230630215747069](http://124.221.95.230:9001/markdown/imgs/image-20230630215747069.png)

【答案】

(SP)	=	010AH
(SS)	=	0330H
(CS)	=	0104H
(IP)	 =	0140H
(FLAGS)= 1440H
栈顶的三个字为:
0330H: 010AH	01A4H
0330H: 010CH	0802H
0330H: 010EH	1240H

【解析】`INT 14H`是x86汇编语言中的一个中断指令，它将暂停当前程序的执行，然后跳转到一个预先定义的中断处理程序去执行。在这个过程中，当前程序的上下文（包括代码段寄存器CS、指令指针寄存器IP和标志寄存器FLAGS）会被保存到堆栈中，以便在中断处理程序执行完毕后能恢复当前程序的执行。

在这个例子中，中断指令`INT 14H`的执行将会保存当前的CS、IP和FLAGS到堆栈中。这个过程可以按以下步骤理解：

1. CS寄存器的内容（即0802H）会被推入栈顶，并且栈指针SP会减2（从0110变为010E）。

2. IP寄存器的内容（即01A4H，这是INT 14H指令后的下一条指令的偏移地址）会被推入栈顶，并且栈指针SP会再减2（从010E变为010C）。

3. FLAGS寄存器的内容（即1240H）会被推入栈顶，并且栈指针SP会再减2（从010C变为010A）。

4. 接着，中断向量表中的相应项（在这个例子中，INT 14H对应的中断向量是(00052) =0104，(00050)=0140）将被加载到CS和IP寄存器中，所以CS=0104H，IP=0140H。

5. 最后，FLAGS寄存器的IF（中断使能）标志位和TF（陷阱标志）位被清零。这意味着在中断处理程序执行期间，将禁止其他的中断。所以，FLAGS=1240H AND 0F7FFH = 1440H。

因此，执行INT 14H指令后，SP, SS, CS, IP, FLAGS的内容分别为：

(SP)	=	010AH
(SS)	=	0330H
(CS)	=	0104H
(IP)	 =	0140H
(FLAGS)= 1440H

栈顶的三个字为:

0330H: 010AH	01A4H
0330H: 010CH	0802H
0330H: 010EH	1240H



## 编程题

1. 请编写一个递归子程序，计算1~N (N=100) 的和。

   SUM(N)=1(当N=1时)
   SUM(N) = N + SUM(N-1) (当N>1时)。
   子程序说明文件如下:
   (1)子程序名: SUM;
   (2)子程序功能:求1~N的和;
   (3)入口参数: CX=N;
   (4)出口参数: AX=1~N 的和;

【答案】

```assembly
SUM PROC NEAR
    PUSH  CX
    CMP	  CX，1
    JE    BACK
    DEC   CX
    CALL  SUM
    INC   CX
    ADD   AX, CX
    JMP   EXIT
    BACK: 
        MOV  AX, 1
    EXIT: 
        POP  CX
        RET
SUM ENDP
```

【解析】这是一个用汇编语言实现的递归函数，它计算从1到N（N在这里是存储在CX寄存器中的值）的和。

函数开始时，首先将CX寄存器的值压入堆栈中，以保存其当前值。

然后，它会检查CX是否等于1。如果是，它会跳转到标签BACK，设置AX的值为1，然后跳转到EXIT，退出子程序。

如果CX的值大于1，它会将CX的值递减1，并调用自身进行递归。当递归调用返回时，它会增加CX的值，然后将CX的值加到AX寄存器中。

最后，在EXIT标签下，它会从堆栈中弹出之前保存的CX的值，并执行RET指令返回到调用它的程序。

通过这种方式，该函数可以计算出从1到N的所有整数的和，并将结果保存在AX寄存器中。





2. 设内存中有三个互不相等的无符号字数据,分别存放在TAB开始的字单元,编制程序将其中最大值存入MAX单元。
   (例如:三个无符号数为TAB DW 1234H, 8245H, 2987H)

【答案】

```assembly
DSEG  SEGMENT
TAB  DW  1234H, 8245H, 2987H
MAX  DW  ?
DSEG  ENDS
CSEG  SEGMENT
ASSUME CS:CSEG,DS:DSEG
FMAX:
	MOV  AX, DSEG
	MOV  DS, AX
    LEA	 SI,TAB
    MOV  AX,[SI]
    MOV  BX,[SI+2]
    CMP  AX,BX
    JAE  FMAX1
    MOV  AX,BX
    FMAX1: 
        CMP AX,[SI+4]
        JAE FMAX2
        MOV AX,[SI+4]
    FMAX2:
        MOV MAX,AX
        MOV AH,4CH
        INT 21H
CSEG ENDS
END FMAX
```

【解析】这个汇编程序的目标是找出存储在内存中的三个互不相等的无符号字数据中的最大值，并将最大值存储在MAX单元。

1. 程序开始时，首先将数据段DSEG的地址加载到数据段寄存器DS中，以便访问内存中的数据。然后，它使用`LEA`指令（Load Effective Address）将数据TAB的地址加载到源索引寄存器SI中。

2. 接下来，程序通过寄存器SI来访问TAB中的数据。它首先将第一个数据加载到寄存器AX中，然后将第二个数据加载到寄存器BX中。然后，它使用`CMP`指令比较AX和BX中的数据，如果AX大于或等于BX，它将跳转到FMAX1，否则，它将将BX中的值移动到AX中。

3. 在FMAX1标签处，程序将AX中的值与第三个数据进行比较。如果AX的值大于或等于第三个数据，它将跳转到FMAX2，否则，它将第三个数据加载到AX中。

4. 最后，在FMAX2标签处，程序将寄存器AX中的最大值存储在MAX单元中。然后，它使用`MOV AH,4CH`和`INT 21H`指令结束程序。

总的来说，这个汇编程序通过逐个比较三个数来找出最大值，并将其存储在MAX单元中。