# 汇编笔记

<p align="right"><i><font color=#0000FF> ——made by njtech_计2104 Melody</font></i></p>

```C++
int main()
```

## 引言

汇编语言是一种低级编程语言，它允许程序员直接与计算机的硬件交互。尽管现代的高级编程语言更常用且更易于学习，但学习汇编语言可以提供对计算机工作方式的深入理解，尤其是对于计算机内存、CPU 和操作系统。

> **常见的汇编语言**：
>
> 1. **x86汇编：** x86汇编用于x86架构的微处理器，如Intel和AMD的处理器。这种汇编语言广泛应用于PC和服务器。x86-64（或称为AMD64）是x86架构的64位版本。
>
>    > 2021年9月上架的“机械革命蛟龙7”笔记本的CPU处理器为“AMD Ryzen 9 5900HX”，是一种AMD处理器
>    >
>    > 2023年4月上架的“联想拯救者9000P”笔记本的CPU处理器为 "i9-13900HX"，是一种intel处理器
>
> 2. **ARM汇编：** ARM汇编语言主要用于ARM架构的微处理器。这种架构常用于嵌入式系统和移动设备，如智能手机和平板电脑。
>
> 3. **MIPS汇编：** MIPS架构以其简洁的指令集和高效的性能著称，广泛应用于嵌入式系统和超级计算机。MIPS汇编语言就是用于编写MIPS处理器的代码。
>
> 4. **PowerPC汇编：** PowerPC是一种RISC（精简指令集计算）架构，曾经被Apple用于其Macintosh计算机。尽管Apple已经转向了x86和ARM，但PowerPC仍在游戏机（如早期的Xbox 360和PlayStation 3）和嵌入式市场中使用。
>
> 这些汇编语言的主要区别在于它们对应的硬件架构和指令集。例如，x86架构是一种复杂指令集计算（CISC）架构，它有大量的指令和复杂的寻址模式。而ARM和MIPS则是精简指令集计算（RISC）架构，指令数量较少，结构更简单。
>
> Windows和Linux使用x86汇编，主要是因为x86架构的微处理器（如Intel和AMD的处理器）长期以来一直是个人电脑和服务器市场的主导。x86架构具有丰富的软件兼容性和强大的性能，使其成为这些系统的理想选择。
>
> 然而，随着ARM架构性能的提升和能效的优势，现在也有越来越多的设备和系统开始采用ARM。例如，Apple的M1芯片就是基于ARM架构，同时也支持运行MacOS和各种应用程序。而在服务器市场，ARM也开始逐渐取得一些份额。
>
> **在本文中，我们只介绍x86汇编语言**



写于2023年5月18日，笔者为一名上课从来没有听过老师上课的大二学生，在上午的一整个上机课中，老师没有告诉你编译环境和调试器是如何运作，以及明明是这一门针对低层的编程代码，却仍像学C++，python一样生硬套代码。缺乏对低层硬件的了解，我们恐怕很难深入学习汇编语言。因此，我将以层层递进的角度，结合处理器的功能结构出发，尽可能做到知其然并知其所以然。在本文中，存在列举大量额外知识点的情况，有些情况下我们并不需要全部仔细读完(例如上文出现了汇编语言的列举)，只是为了在宏观的角度看待一个问题。





### 什么是汇编器？

汇编器是一种计算机程序，它把汇编语言编写的源代码（人类可读的指令）转换成机器语言（计算机可执行的指令）。简单来说，汇编器的任务就是把你写的汇编代码翻译成计算机可以理解和执行的二进制代码。

汇编器主要完成两项工作：

- **词法分析**：这一阶段，汇编器会检查源代码中的每一个字符，并将字符组织成有意义的序列，这些序列被称为标记（tokens）。例如，一行代码中的指令、标签、操作数都是标记。
- **语法分析**：在这一阶段，汇编器会根据一组规则（语法），检查标记的组合是否有意义。如果语法正确，汇编器会生成一个二进制文件，该文件可以被加载到内存中执行。







### 学习路线

学习x86汇编语言的路线可以如下：

1. **基本概念：** 首先，你需要理解计算机的基本组成，比如中央处理器（CPU）、内存（RAM）、硬盘等。理解二进制和十六进制的基础知识是非常重要的，因为在汇编语言中，你会频繁地接触这两种数制。同时，你也需要理解什么是指令集，以及x86架构的基本特性。
2. **环境设置：** 安装一个汇编器，比如NASM，以及一个适合你的文本编辑器或集成开发环境（IDE）。你也可能需要一个调试器，比如GDB，它可以帮助你理解你的代码在执行时发生了什么，从而找出可能存在的问题。
3. **学习基本语法和指令：** 理解汇编语言的基本语法，包括如何定义数据、如何进行算术运算、如何控制程序流程等。你需要学习一些基本的汇编指令，比如`mov`（移动或复制数据）、`add`（加法）、`sub`（减法）、`jmp`（跳转到程序的另一部分）等。
4. **编程实践：** 开始编写一些简单的汇编程序，比如实现两个数字的加法运算、一个简单的循环结构等。通过编程实践，你可以更好地理解汇编语言的工作方式。
5. **理解寄存器：** 寄存器是CPU中的一种非常快速的存储设备。在x86汇编中，你会频繁地操作寄存器。理解每个寄存器的功能，以及如何使用它们，是非常重要的。
6. **内存管理：** 学习如何在汇编语言中操作内存，包括如何加载和存储数据，如何分配和释放内存等。
7. **系统调用：** 学习如何在汇编语言中进行系统调用，以实现一些更复杂的功能，比如读写文件、接收用户输入等。
8. **理解中断和异常：** 中断和异常是计算机系统中的重要概念。理解它们的工作原理，以及如何在汇编语言中处理它们，是学习x86汇编的重要部分。
9. **阅读复杂的代码：** 当你掌握了基本的概念和技巧后，你可以开始阅读一些更复杂的汇编代码，以提高你的技能。这可能包括一些开源的汇编程序，或者一些著名的操作系统





## 配置环境



1. 下载 [Visual Studio Code](https://code.visualstudio.com/)

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518085712043.png" alt="image-20230518085712043" style="zoom: 33%;" />

2. 安装 MASM/TASM 插件

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518085831223.png" alt="image-20230518085831223" style="zoom:50%;" />

3. 配置DOS的环境和选择编译器

   点击扩展设置

   <img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518090056154.png" alt="image-20230518090056154" style="zoom: 33%;" />

   配置以下设置

   ![image-20230518090132970](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518090132970.png)

现在，你可以在代码页中右键菜单中运行代码了

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230518090231037.png" alt="image-20230518090231037" style="zoom: 50%;" />



在配置环境中，你使用了 **MASM** 作为汇编工具，使用 **dosbox** 作为DOS环境模拟器，下面我们将介绍 **dosbox**.



## 什么是dosbox？

DOSBox是一个开源的模拟器，用于模拟早期的DOS（Disk Operating System）操作系统环境。它的主要目的是在现代的操作系统中运行旧的DOS程序和游戏。

> DOS（Disk Operating System）是一种磁盘操作系统，最早由微软（Microsoft）开发。它最初是为IBM的个人计算机（PC）设计的，于1981年与IBM PC一起发布，并成为早期个人计算机的主要操作系统。以下是DOS的历史和当今现状的简要介绍：
>
> 1. DOS的特点：
>    - 命令行界面：DOS采用基于文本的命令行界面，用户通过键入命令来执行操作。
>    - 单任务操作系统：早期的DOS版本是单任务操作系统，只能同时运行一个程序。
>    - 文件系统：DOS使用FAT（File Allocation Table）文件系统，后续版本引入了FAT32来支持更大的磁盘容量。
>    - 缺乏图形界面：早期的DOS版本没有图形用户界面（GUI），用户主要通过文本模式界面进行操作。
> 2. 当今现状：
>    - 历史地位：DOS在个人计算机的发展中起到了重要的推动作用，但随着图形用户界面和先进操作系统的崛起，如Windows、Mac OS和Linux，DOS已经逐渐退出了主流计算机市场。
>    - 嵌入式系统：尽管DOS在桌面计算机领域的影响力减弱，但它在嵌入式系统中仍然存在。一些嵌入式设备和专用系统仍在使用定制的DOS版本来实现特定的功能和控制。
>    - 怀旧和学习：一些人对DOS怀有情感，或者将其用作学习计算机历史和汇编语言编程的平台。DOSBox等模拟器使得在现代计算机上运行DOS程序成为可能。
>
> DOS在计算机发展史上具有重要的地位，虽然它在当前计算机市场中已经较少使用，但仍有人对其保持兴趣，并将其视为计算机技术的重要里程碑之一。

作为一个模拟器，他具备了调试的功能，因此在本次教程中不需要安装任何调试器。

> **什么是调试器？**
>
> 调试器是一个用于测试和调试其他程序的软件工具。当程序发生错误或异常时，调试器可以用于检查程序的内部状态，找出错误发生的原因。
>
> 调试器的主要功能包括：
>
> - **断点**：这是调试器中最常用的一个功能。断点可以设置在特定的代码行，当程序执行到这一行时，程序会暂停，这样你就可以检查此时程序的状态。
> - **单步执行**：这个功能可以让你一步一步地执行程序。每执行一步，你都可以看到程序状态的变化。
> - **变量查看和修改**：当程序暂停时，你可以查看和修改变量的值，这对于理解程序的行为和调试问题非常有用。
> - **调用栈查看**：调试器允许你查看程序的调用栈。调用栈是一个记录了函数调用历史的结构，通过查看调用栈，你可以知道程序是如何达到当前状态的。



## x86处理器



### 内存

“内存”是一个用来在电脑或其他数字计算机设备中临时存储信息的组件。它是计算机硬件中的一个关键部分，处理器可以从中读取数据和向其中写入数据。计算机的各种程序和操作系统都依赖内存来执行操作。

内存可以看作是一个存储空间或者说是一种资源，它能够容纳数据和指令。CPU可以迅速地访问内存中存储的信息。当我们打开一个应用程序或者文件时，它们就会被加载到内存中，以便CPU能够快速地访问和处理。

计算机内存的类型有很多，比如：

1. RAM（随机存取存储器）：这是最常见的内存类型，它是易失性的，也就是说，当计算机断电时，RAM中的所有数据都会丢失。但是，RAM的数据访问速度很快，因此它通常被用来存储操作系统，应用程序和实时运行的数据。
2. ROM（只读存储器）：这种类型的内存包含了计算机启动时需要的固定程序。ROM中的数据是不易失性的，即使在断电的情况下也不会丢失。
3. Cache：这是一种非常快速的内存，位于CPU和主内存之间，它可以存储经常使用的数据和指令，从而提高处理器的性能。
4. 寄存器：这是位于CPU内部的非常小但极快的内存区域，用于存储即将被CPU执行的指令和数据。
5. 虚拟内存：这是一种在硬盘上创造的内存，当RAM用完时，操作系统会将部分数据“换出”到虚拟内存中，虽然比RAM慢，但大大增加了可用的内存空间。



### 8086/8086处理器

8086处理器是Intel公司于1978年推出的一款16位微处理器，被广泛应用于个人电脑的早期阶段。它是Intel x86处理器家族的一员，也是x86架构的开端。8086处理器具有许多重要特性，对于个人计算机的发展起到了重要的推动作用。

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/5fdf8db1cb1349549250e7ce87d6685ed0094a69.jpeg" style="zoom:50%;" />

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/30adcbef76094b3658a39d26775486df8c109d6c.jpeg" style="zoom:50%;" />

1. **Adder（加法器）**：在微处理器中，加法器是算术逻辑单元（ALU）的一部分，用于执行加法运算。这对于大多数计算机指令（如算术运算，地址计算等）来说都是必需的。
2. **Upperregs（上部寄存器）和 Lowerregs（下部寄存器）**：这些是指8086的16位寄存器，它们被分为上部和下部，可以分别以8位或16位的形式访问。例如，AX寄存器可以被分为AH（上部）和AL（下部）。
3. **ALU（算术逻辑单元）**：这是处理器的核心部分，用于执行所有的算术和逻辑运算。在8086中，ALU能处理16位数据，支持诸如加法、减法、逻辑与、逻辑或等操作。
4. **Control（控制单元）**：控制单元负责从内存读取指令，解码这些指令，然后控制微处理器的其他部分按照这些指令进行操作。控制单元决定了计算机的操作顺序。
5. **Decode（解码器）**：解码器是控制单元的一部分，其作用是将获取的指令解码成一组能被微处理器其他部分理解的信号。
6. **Microcode（微指令）**：微指令是微处理器内部使用的一组详细指令，用于实现机器语言指令。一条机器语言指令可能会被解码成一系列的微指令，这些微指令由微处理器内部的微指令控制器来执行。

#### 寄存器

8086的寄存器是一个16位的寄存器。

> “位”是计算机科学中的基本概念，用来描述数据的大小。一位（bit）是二进制数据的最小单位，可以表示0或1。因此，“16位”寄存器可以存储16个二进制位的数据，即2的16次方（65536）种不同的值。



8086是一款16位微处理器，它拥有多个寄存器，这些寄存器可以分为几类：通用寄存器、段寄存器、指针和索引寄存器、状态和控制寄存器。以下是对这些寄存器的简要描述：

1. **通用寄存器**：包括AX、BX、CX和DX，这些寄存器可以进一步拆分为两个8位寄存器（如，AX可以拆分为AH和AL）。这些寄存器主要用于数据操作：
   - AX（累加器）：主要用于算术、逻辑和数据传输操作。
   - BX（基地址寄存器）：它可以作为一个指针来使用，用于数据操作。
   - CX（计数寄存器）：通常在循环和字符串操作中用作计数器。
   - DX（数据寄存器）：通常用于I/O操作和某些乘法和除法操作。
2. **段寄存器**：包括CS、DS、SS和ES，这些寄存器用于存储当前正在使用的代码、数据和堆栈段的地址：
   - CS（代码段寄存器）：存储当前执行代码的地址。
   - DS（数据段寄存器）：存储当前使用的数据段的地址。
   - SS（堆栈段寄存器）：存储当前使用的堆栈段的地址。
   - ES（附加段寄存器）：作为数据段寄存器的补充，存储额外的数据段地址。
3. **指针和索引寄存器**：包括SP、BP、SI和DI，这些寄存器通常用于字符串操作和内存访问：
   - SP（堆栈指针）：指向堆栈顶部的指针。
   - BP（基址指针）：主要用于堆栈段的数据访问。
   - SI（源索引）：主要用于字符串操作，指向源数据。
   - DI（目标索引）：主要用于字符串操作，指向目标数据。
4. **状态和控制寄存器**：包括IP和Flags：
   - IP（指令指针）：存储下一条将要执行的指令的地址。
   - Flags（标志位）：用于存储处理器的状态信息，例如零标志（ZF）、进位标志（CF）、符号标志（SF）等。



尽管你可以把一些数据从AX移动到BX上（即混淆每个寄存器的作用），但我并不建议你这么做，因为有一些底层设计是专门针对不同寄存器而设计的。



### 寻址

在8086微处理器中，一个完整的物理地址是由一个16位的段地址和一个16位的偏移地址组合而成的。具体的计算方式是：将段地址左移4位（也就是乘以16，或者说乘以十六进制的1000h），然后再加上偏移地址。这种方式允许我们从两个16位的值生成一个20位的物理地址。

对于段地址和偏移地址，我的理解是真的只是为了定义而起了两个名字，没有什么特殊的含义，你只需要知道，在计算机的表示格式为“段地址：偏移地址”即可。

> 在表示地址中，尽管寄存器为16位，但并不会以"0000 0000 0000 0000 "来表示，因为这样太长且不利于阅读，因此采用16进制来表示，比如："1011 1000 1111 0001" 对应的16进制数为"B8F1" ，

以“1234:1234” 地址为例，他的20位地址计算图如下：

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521174417254.png" alt="image-20230521174417254" style="zoom:67%;" />

因此可以得出一个结论：**8086最大可表示的存储单元数为 $2^{20} \mathrm{b}=1,048,576 \mathrm{b} = 1024 \mathrm{kb} = 1 \mathrm{m}$** 





## 第一个汇编程序

```assembly
data segment
    x db 30
data ends

code segment

    start:
        mov ax, data
        mov ds, ax
        
        mov al, ds:[x]

code ends

end start

```

你可能会好奇，运行结果是什么？ 先别急，在认识这个程序之前，我需要告诉你一些汇编语言中的关键字和调试器的知识。



### 编程入门

在**x86汇编语言**中，代码由段（segment）组成，在运行时，代码会被以内存的方式存储在内存中，段的定义方式为：

```assembly
段名 segment

段名 ends
```



在代码中，你还需要指定函数的入口（类似于C++的 `int main()` ）与高级编程语言不同，函数的入口名不是一个关键字，你只需要在代码的末尾 `end` 中指定入口名即可：

```assembly
code1 segment

	kaishi:

code1 ends

end kaishi
```



由此可见，段和入口名均可自定义，但为了规范，还是建议按照功能来命名，其中对于段，可以有4个种类：

1. 代码段（Code Segment）：这个段通常包含了程序的指令。即程序的机器代码，例如：

   ```
   code segment
       mov ax, data
       mov ds, ax
       mov ah, 9
       lea dx, message
       int 21h
       mov ax, 4C00h
       int 21h
   code ends
   ```

2. 数据段（Data Segment）：这个段通常包含了程序的数据。比如变量、常量、数组等，例如：

   ```
   data segment
       message db 'Hello, World!', '$'
   data ends
   ```

3. 堆栈段（Stack Segment）：这个段用来存放程序的运行堆栈。它被用于临时存储数据和返回地址，例如：

   ```
   stack segment
       dw 128 dup(0)
   stack ends
   ```

4. 额外段（Extra Segment）：这个段可以用来存放额外的数据，它通常被用于字符串或者其他大量数据的操作。



对于代码段，我们可以发现，一段完整的代码通常由 “ 操作指令 参数A [ , 参数B ] ” 组成，下面介绍前文出现过的操作指令：

- `mov`：将参数B的地址移动到标签A中
- `lea`："load effective address"的缩写，它的作用是计算参数B的地址，并将结果存放在参数A中。
- `int`：调用DOS中断参数A



1. `segment` 和 `ends`: 这两个关键字用于定义一个内存段。在8086和x86汇编中，内存被划分为不同的段，如数据段（data segment）、代码段（code segment）等。`segment`关键字表示开始一个新的段定义，而`ends`关键字表示一个段的结束。
2. `db`：这是定义字节（Define Byte）的缩写，用于在数据段中定义一个字节的数据。
3. `mov`：这是移动（Move）的缩写，是一个指令，用于将数据从源操作数复制到目标操作数。在这个例子中，`mov ax, data`和`mov ds, ax`两行将数据段地址复制到数据段寄存器（DS）中。
4. `ds:[x]`: 这个表达式表示在数据段（DS）中的`x`标签位置的内存地址。这里的冒号不是一个关键字，而是一种语法符号，表示的是段和偏移量的关系。`ds:`是选择器，表示我们正在引用的是数据段，`[x]`则是偏移量，表示从该段开始的内存位置。
5. `ax` 和 `al`：这两个都是寄存器名称。在x86架构中，`ax`是一个16位的寄存器，而`al`是`ax`寄存器的低8位。
6. `start:`：这是一个标签，表示一个位置的名称。在这里，`start`是程序的入口点。
7. `code` 和 `data`: 这两个是段名。在这个例子中，`data`是数据段的名字，`code`是代码段的名字。
8. `end`: 这个关键字用来表示程序的结束，它后面通常跟着程序的入口点名称，表示程序应该从哪里开始执行。





### 调试

Debug是一个在MS-DOS和一些Windows环境下的命令行调试工具。你可以使用它来执行、调试和测试程序。在Debug环境下，你可以使用如下的一些指令：

1. **-t（Trace）**：这个指令可以让你单步执行程序。每次执行一条指令后，Debug会显示CPU的状态，包括寄存器的值和标志的状态。
2. **-g（Go）**：这个指令可以让你开始或继续运行程序，直到程序结束，或者遇到一个断点。
3. **-p（Proceed）**：这个指令和"g"指令类似，但是它会在每次调用或返回指令后暂停程序的执行。
4. **-r（Register）**：这个指令可以让你查看和修改寄存器的值。
5. **-d（Dump）**：这个指令可以让你查看内存的内容。
6. **-e（Enter）**：这个指令可以让你修改内存的内容。
7. **-a（Assemble）**：这个指令可以让你在内存中输入汇编语言指令。
8. **-u（Unassemble）**：这个指令可以让你将内存中的机器代码反汇编为汇编语言指令。
9. **-q（Quit）**：这个指令可以让你退出Debug。



在了解了代码究竟在写什么之后，我们一起来看看调试模式下的“第一个汇编程序”发生了什么

在 **vscode** 中右键代码选择 "调试当前程序(汇编+链接+调试" 然后输入"r" 

![image-20230521202626502](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521202626502.png)

该结果告诉了如下信息：

- 所有寄存器的值（从AX到IP），

- "NU UP EI PL NZ NA PO NC"这些是处理器的状态标志，表示不同的处理器条件。这些标志由CPU在执行指令后自动设置或清除，表示特定的条件或状态（如零标志（Z）、进位标志（C）、溢出标志（O）、符号标志（S）等）。
- "076D:0000 B86C07 MOV AX, 076C"表示当前（下一个要执行的）指令（在地址076D:0000）是将076C这个值移入AX寄存器。



接着，我们可以输入"t"

![image-20230521203150047](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521203150047.png)

对比上图，我们可以发现，"AX" 的值已经变为"076C" 下一指令是"把AX的地址移动到DS上"，我们接着输入"t"

![image-20230521203257209](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521203257209.png)

对比上图，我们可以发现，“移动”的本质就是拷贝了一份地址，由此，我们可以看到“DS”寄存器的值也变为了“076C”，而除了告诉我们下一指令是移动以外，在右边还出现了新的提示“DS:0000 = 1E ” 意思是该地址的值是20，我们可以输入"d 076C:0000" 验证一下

![image-20230521203530193](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521203530193.png)

这部分的信息量有点大，我们逐一解释：首先，左边的一列代表了地址，中间每一行（16个）展示了每个地址对应的子节信息（以16进制表示），右边则排列对应子节的ASCll字符。举个例子， 对于地址"076C:0000" 他的值是1E(即20)，由于他的ASCll无法以正常的字符表示，所以他默认为".",对于地址"076C:68",他的值是74（即116），对应字符"t"

> 其实中间的"-" 没有任何意义，他写出来是为了方便你看那16个数字，不然看到眼睛痛 —。—

> 两个16进制恰好能表示8位二进制，1子节指的就是8位二进制



我们接着输入"t" 查看

![image-20230521204247244](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521204247244.png)

在前文，我们已经知道，对于一个16位寄存器，还可以分为两个8位寄存器(高位和低位)，因此在该操作中，我们把“30”这一个值移动到了AX的低位寄存器（AL）上，注意，一旦我们进行了数据移动操作后，16位寄存器已经不为一个正确的存地址的寄存器（上图071E是一个未知的地址，因此不能当地址用）





## 编程



### 功能号与int中断指令

`int 21h` 是一个软件中断指令，用于调用DOS（Disk Operating System）功能。通过在`ah`寄存器中设置特定的功能号，可以使用`int 21h`来执行各种与DOS相关的操作。下面列一些个 `int 21h` 调用的含义和作用：

1. - `int 21h`，功能号`00h`：
     - 含义：程序终止。
     - 作用：终止程序的执行。
   - `int 21h`，功能号`01h`：
     - 含义：从标准输入获取一个字符。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中。
   - `int 21h`，功能号`02h`：
     - 含义：将字符输出到标准输出。
     - 作用：将`dl`寄存器中的字符显示在屏幕上。
   - `int 21h`，功能号`06h`：
     - 含义：将字符输出到标准输出（无回显）。
     - 作用：将`dl`寄存器中的字符显示在屏幕上，但不在屏幕上显示光标。
   - `int 21h`，功能号`08h`：
     - 含义：从标准输入获取一个字符（无回显）。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，但不在屏幕上显示字符。
   - `int 21h`，功能号`09h`：
     - 含义：显示字符串。
     - 作用：将存储在`dx`寄存器指向的字符串输出到屏幕上。
   - `int 21h`，功能号`0Ah`：
     - 含义：从标准输入获取一个字符并缓冲。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，同时将其缓冲以供后续读取。
   - `int 21h`，功能号`0Ch`：
     - 含义：获取当前打印页号。
     - 作用：将当前打印页号存储在`al`寄存器中。

#### 常用功能号

| AH   | 描述                               |
| ---- | ---------------------------------- |
| 00h  | 程序终止                           |
| 01h  | 从标准输入获取一个字符             |
| 02h  | 将字符输出到标准输出               |
| 06h  | 将字符输出到标准输出（无回显）     |
| 08h  | 从标准输入获取一个字符（无回显）   |
| 09h  | 显示字符串                         |
| 0Ah  | 从标准输入获取一个字符并缓冲       |
| 0Ch  | 获取当前打印页号                   |
| 0Eh  | 将字符输出到标准输出并保留光标位置 |
| 25h  | 设置DOS版本号                      |
| 2Ch  | 获取系统时间                       |
| 30h  | 获取DOS版本号                      |
| 33h  | 设置断点                           |
| 35h  | 获取磁盘参数                       |
| 3Dh  | 打开文件                           |
| 3Eh  | 关闭文件                           |
| 3Fh  | 读取文件                           |
| 40h  | 写入文件                           |
| 4Bh  | 加载和执行程序                     |
| 4Ch  | 程序终止，并返回错误级别           |



## 上机作业一

上机过程和DEBUG介绍:了解并掌握汇编语言源程序。上机练习的过程(四个步骤)：编辑、汇编、连接和调试。

题目一：Debug调试程序

题目二：X=30，Y=15，求 X + Y, X - Y，X * Y分别保存至 z1，z2， z3 变量中。



下面使用 **Debug** 调试程序完成题目二的内容。

```assembly
data segment
    x db 30
    y db 15
    z1 db ?
    z2 db ?
    z3 dw ?
data ends

code segment

    start:
        mov ax, data
        mov ds, ax

        mov al, ds:[x]
        add al, ds:[y]
        mov ds:[z1], al

code ends

end start

```

![image-20230521210538243](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521210538243.png)

1. 关于MUL指令：`MUL`指令在8086汇编语言中是用来进行无符号乘法操作的。这个指令只接受一个操作数，它会将这个操作数与`AL`（如果操作数是8位的）或`AX`（如果操作数是16位的）寄存器的内容相乘，然后将结果放置在`AX`（如果操作数是8位的）或`DX:AX`（如果操作数是16位的）寄存器对中。所以，当你执行`MUL ds:[y]`时，实际上你是在将`y`的值与`AL`寄存器的内容相乘，所以不需要再次指定`ds:[x]`。

2. 为在8086处理器中，乘法结果的存储方式是小端序（Little Endian）。小端序是指在多字节数据中，最低有效字节在最低的内存地址，最高有效字节在最高的内存地址。这意味着如果一个16位数存储在两个字节中，低字节将被首先存储。

   在本题中，30*15等于450。如果我们将450转换为十六进制，我们将得到`01C2`。在小端序中，它将以`C2 01`的形式存储。所以，当检查`DS:0004`（即`z3`）时，你看到的是`C2`，这是450的低8位部分。如果你继续查看下一个字节`DS:0005`，你应该能看到`01`，这是450的高8位部分。



## 上机作业二

题目一：统计学生成绩设有10个学生的成绩分别为46、68、88、87、76、89、99、65、 100和80分。试编制程序统计低于60分、60~69 分、70~79分、 80~89 分、90~99分及100分的人数，并存放到S5、S6、S7、S8、S9及S10单元中。

```assembly
data segment
    scores db 46, 68, 88, 87, 76, 89, 99, 65, 100, 80
    S5 db 0
    S6 db 0
    S7 db 0
    S8 db 0
    S9 db 0
    S10 db 0
data ends

code segment

    start:
        mov ax, data
        mov ds, ax
        mov cx, 10 ; 分数数量
        lea bx, scores ; bx指向分数数组

        count_loop:
            mov al, [bx] ; 读取分数
            cmp al, 60
            jb below60
            cmp al, 70
            jb from60to69
            cmp al, 80
            jb from70to79
            cmp al, 90
            jb from80to89
            cmp al, 100
            jb from90to99
            jmp is100

        below60:
            inc byte ptr ds:[S5]
            jmp next_score

        from60to69:
            inc byte ptr ds:[S6]
            jmp next_score

        from70to79:
            inc byte ptr ds:[S7]
            jmp next_score

        from80to89:
            inc byte ptr ds:[S8]
            jmp next_score

        from90to99:
            inc byte ptr ds:[S9]
            jmp next_score

        is100:
            inc byte ptr ds:[S10]

        next_score:
            inc bx ; 移动到下一个分数
            loop count_loop ; 如果还有分数则重复循环

        int 3  ; 中断指令，用于打断点
            
        

    code ends
end start

```

![image-20230521212905759](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521212905759.png)



题目二：对键盘键入的小写字母用大写字母显示出来；若键入的为非字母键，则程序结束。

```assembly
data segment
    prompt db 'Please enter a character: $'
    output db 'Your character: $', 0
    newline db 0Dh, 0Ah, '$' ; newline (CR LF)
data ends

code segment
    start:
        mov ax, data
        mov ds, ax

        get_input:

            lea dx, prompt
            mov ah, 09h
            int 21h ; 将存储在`dx`寄存器指向的字符串输出到屏幕上。

            mov ah, 01h
            int 21h ; 等待用户从键盘输入一个字符，并将其存储在`al`寄存器中。

            ; 比较字符
            cmp al, 'a'
            jb end_program
            cmp al, 'z'
            ja end_program

            ; 转换为大写字符
            sub al, 20h

            display_output:
                mov dl, al
                mov ah, 02h
                int 21h ; 将`dl`寄存器中的字符显示在屏幕上。


                lea dx, newline
                mov ah, 09h    
                int 21h ; 输出回车

                jmp get_input

        end_program:
            mov ah, 4Ch
            int 21h ; Terminate program

code ends
end start

```

![image-20230521215846389](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230521215846389.png)



在ASCII编码中，换行通常由两个字符表示：回车（CR，ASCII值为13或0Dh）和换行（LF，ASCII值为10或0Ah）。

这种表示方式起源于打字机和电传打印机的操作方式：回车（CR）是移动打印头到行首，而换行（LF）是移动纸张到下一行。在现代计算机系统中，通常一起使用这两个字符来表示换行。





## 附录

### 文件类型

以下是一些常见的与汇编相关的文件类型及其用途：

1. **.asm：** 这是汇编源代码文件。这些文件包含用汇编语言编写的程序源代码。这些代码是人类可读的，并且可以通过汇编器转换成机器语言。
2. **.o / .obj：** 这些是目标文件。当你运行汇编器时，它会将你的.asm源代码文件转换成.obj或.o的目标文件（文件后缀取决于你使用的操作系统）。这些目标文件包含了机器语言代码，但不能直接执行，因为它们还没有被链接到可以在你的系统上运行的可执行文件。
3. **.exe / .out / .bin：** 这些是可执行文件。链接器取.obj或.o的目标文件，并将它们链接成一个可以在你的系统上直接运行的可执行文件。在Windows中，这些文件通常有.exe的扩展名，在Unix或类Unix系统（如Linux或macOS）中，它们通常没有扩展名或有.out、.bin等扩展名。
4. **.lib / .a：** 这些是库文件。它们包含一组可以被其他程序复用的目标文件。在Windows中，这些文件通常有.lib的扩展名，在Unix或类Unix系统中，它们通常有.a的扩展名。
5. **.dll / .so：** 这些是动态链接库文件。它们包含一组在运行时可以被其他程序调用的函数和数据。在Windows中，这些文件通常有.dll的扩展名，在Unix或类Unix系统中，它们通常有.so的扩展名。

总的来说，这些文件类型共同参与了程序的编译、链接和运行过程。其中，`.asm` 文件是程序的源头，`.o/.obj` 、.`lib/.a`、`.dll/.so`文件是编译和链接过程中的中间产物，而 `.exe/.out/.bin` 文件则是最终的可执行程序。



### 常见的汇编器

以下是一些常见的汇编器：

1. **NASM（Netwide Assembler）：** NASM是一个开源的x86汇编器，它可以用于Windows、Linux和MacOS。NASM使用Intel语法，易于学习和使用，因此常常推荐给初学者。此外，NASM生成的目标文件可以与多种编译器生成的文件链接，提供了很大的灵活性。
2. **MASM（Microsoft Macro Assembler）：** MASM是Microsoft的官方汇编器，它也使用Intel语法。由于MASM与Microsoft的其他开发工具（如Visual Studio）集成得很好，所以如果你在Windows上进行开发，MASM可能会很有用。然而，MASM并不适用于非Windows系统。
3. **GAS（GNU Assembler）：** GAS是GNU项目的官方汇编器，它可以用于所有主流的操作系统。与NASM和MASM不同，GAS默认使用AT&T语法，这可能会让初学者觉得有些难以理解。然而，GAS也可以配置为使用Intel语法。
4. **YASM （Yet Another Assembler）**是一个开源的汇编器，设计目标是成为NASM（Netwide Assembler）的改进版，尤其是在64位和多平台支持方面。YASM与NASM相比，拥有更好的64位支持和更多的输出格式，同时也支持NASM的所有指令和宏。

对于初学者来说，NASM可能是最好的选择，因为它使用广泛，语法直观，且有大量的教学资源。而对于调试器，如果你在Linux或MacOS上工作，GDB是很好的选择。如果你在Windows上工作，你可能会发现OllyDbg的图形用户界面更加易用。





