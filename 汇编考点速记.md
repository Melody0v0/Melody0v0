# 考点速记

<p align="right"><i><font color=#0000FF> ——made by njtech_计2104 Melody</font></i></p>



## 第一部分

### ASCLL码表

![image-20230629161610132](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230629161610132.png)



### 汇编语言源程序与汇编语言

用汇编语言书写的程序称为汇编语言源程序，汇编语言源程序是在编辑程序中形成的。编辑、汇编与连接过程如下：

![image-20230703142845830](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703142845830.png)



### 机器数据总线数

8088/8086 CPU 为16位数据总线数



## 第二部分

### 计算机的基本结构



<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703144518704.png" alt="image-20230703144518704" style="zoom:67%;" />



### 寄存器

寄存器分为3类：**通用寄存器**、**控制寄存器**、**段寄存器**

![image-20230703144610665](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703144610665.png)



通用寄存器：

- AX：累加器
- BX：基地址寄存器
- CX：计数寄存器
- DX：数据段寄存器

指针寄存器：

- SP：堆栈指针
- BP：基址指针
- IP：指令指针寄存器

变址寄存器：

- SI：源变址寄存器
- DI：目的变址寄存器

控制寄存器：

- FLAGS；标志寄存器

  ![image-20230703145249797](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703145249797.png)

  | 符号 | 名称               | 标志位状态           | 功  能                                                       |
  | ---- | ------------------ | -------------------- | ------------------------------------------------------------ |
  | CF   | 进位标志           | CF=1;CY<br />CF=0;NC | CF=1运算结果最高位有进位或有借位（用于多字节加减运算）否则CF=0。 （DEBUG中 CF=1：CY，CF=0：NC） |
  | PF   | 奇偶标志           | PF=1;PE<br />PF=0;PO | 运算结果的低8位中所含“1”的个数为偶数：PF=1，否则PF=0。（DEBUG中 PF=1：PE，PF=0：PO） |
  | AF   | 辅助进位标志       | AF=1;AC<br />AF=0;NA | AF=1：运算结果低四位向高四位有进位或有借位（用于10进制运算指令）否则AF=0 。 （DEBUG中 AF=1：AC，AF=0：NA） |
  | ZF   | 结果为0标志        | ZF=1;ZR<br />ZF=0;NZ | ZF=1运算结果为0，ZF=0运算结果不为0;（DEBUG中 ZF=1：ZR，ZF=0：NZ） |
  | SF   | 符号标志           | SF=1;NG<br />SF=0;PL | 运算结果为正（符号位为0）SF=0; 运算结果为负（符号位为1）SF=1。（DEBUG中 SF=1：NG，SF=0：PL） |
  | OF   | 溢出标志           | OF=1;OV<br />OF=0;NV | 带符号数的运算结果产生溢出时，OF=1;否则OF=0 。（DEBUG中 OF= 1：OV，OF=0：NV） |
  | DF   | 方向标志           | DF=1;DN<br />DF=0;UP | 串操作指令用的标志，DF=1执行字符串操作指令时使地址指针自动增量（字符串处理顺序由低向高进行）;DF=0使地址指令自动减量。可通过指令STD置DF =1，CLD清DF =0（DEBUG中 DF=1：DN，DF=0：OP） |
  | IF   | 中断标志           | IF=1;EI<br />IF=0;DI | 可屏蔽中断的标志;IF=1允许中断（允许CPU响应可屏蔽外部中断）;IF=0禁止中断，关中断;可通过指令STI置IF=1，CLI清IF=0（DEBUG中 IF=1;EI，IF=0;DI） |
  | TF   | TF单步（跟踪）标志 | TF=1<br />TF=0       | CPU按单步跟踪方式执行指令                                    |

段寄存器：

- CS： 代码段寄存器
- DS ：数据段寄存器
- SS ：堆栈段寄存器
- ES ：附加段寄存器



### 工作模式

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703145929683.png" alt="image-20230703145929683" style="zoom:67%;" />



### 物理地址的换算方法

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703150213514.png" alt="image-20230703150213514" style="zoom: 67%;" />





### PPT末练习

【例】在实模式下，段地址和偏移地址为3017:000A的存储单元的物理地址是什么？如果段地址和偏移地址是3015:002A和3010:007A呢？

【答】实模式下的物理地址由段地址和偏移地址两部分组成。这种方式称为段内偏移。物理地址的计算公式为：

```
物理地址 = 段地址 * 16 + 偏移地址
```

这个公式中的 16 是因为在实模式下，段地址向上移动 4 位（也就是乘以16）以生成20位的物理地址。然后，将这个结果与偏移地址相加，得到最终的物理地址。所有的地址和结果都是以16进制（hex）表示的。

以下是三个例子的物理地址计算过程：

1. 对于段地址和偏移地址为3017:000A的存储单元：
物理地址 = 3017 * 16 + 000A = 30170 + 000A = 3017A

2. 对于段地址和偏移地址为3015:002A的存储单元：
物理地址 = 3015 * 16 + 002A = 30150 + 002A = 3017A

3. 对于段地址和偏移地址为3010:007A的存储单元：
物理地址 = 3010 * 16 + 007A = 30100 + 007A = 3017A

所以，尽管这三个例子的段地址和偏移地址不同，但是他们的物理地址都是3017A。这就是实模式下内存管理的一种特点，即存在段地址和偏移地址的重叠问题，不同的段地址和偏移地址可能对应同一物理地址，从而可能导致数据的覆盖和混乱。



【例】如果在一个程序开始执行以前(CS)=0A7F0H (如16进制数的最高位为字母，则应在其前加一个0) ，(IP)=2B40H，问该程序的第一个字的物理地址是多少？

【答】在实模式下，物理地址由代码段寄存器（CS）和指令指针（IP）确定。物理地址的计算公式为：

物理地址 = CS * 16 + IP

给出的 CS = 0A7F0H 和 IP = 2B40H（均为16进制数），我们将这两个数值代入公式计算物理地址：

物理地址 = 0A7F0H * 16 + 2B40H = A7F00H + 2B40H = AAA40H

所以，该程序的第一个字的物理地址为 AAA40H。



### 小端序+内存地址的画法

在"小端序"（Little-Endian）方式中，最低有效字节存储在最小的地址（即最前面的位置），而最高有效字节存储在最大的地址（即最后面的位置）。例如，一个 16 位的整数 0x1234，在内存中的存储形式（以字节为单位）为： 34 12。

![image-20230703151125559](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703151125559.png)



## 第三部分

### 指令的书写格式

```assembly
;操作码 [目的操作数] [，源操作数]
DD AX, BX	; 双操作数指令
INC AX		; 单操作数指令
STD			; 无操作数指令

```



### 提供操作数的方式

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703151538486.png" alt="image-20230703151538486" style="zoom:67%;" />

- **立即数**：常量或者表达式，不能做目的操作数

  ```assembly
  ADD AX，0FFH
  ```

- **寄存器操作数**：存在寄存器的值，看情况视为“内存”或“值”

  - 段寄存器（DS，SS，ES）和控制寄存器的数据必须通过寄存器操作数

    ```assembly
    MOV AX, 2000H
    MOV DS, AX		; (√)
    
    MOV DS, 2000H 	; (x)
    ```

- **内存操作数**：通过内存地址从内存中读写操作数

  ```assembly
  MOV AX，2000H      ; 将立即数2000H送入AX
  MOV AX，[2000H]    ; 将内存单元地址为2000H的内容送入AX
  ```



### 寻址方式

#### 立即数寻址方式

```assembly
MOV AH，12H         ; 12H为字节立即数
MOV AX，1234H       ; 1234H为字立即数
```

#### 寄存器寻址方式

```assembly
MOV  AX，BX   ; 源操作数和目的操作数均为寄存器寻址 
```

#### 存储器直接寻址方式

```assembly
MOV AX，[2000H]
```

![image-20230703153017250](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703153017250.png)

```assembly
DATA SEGMENT
	X DW 2000H
DATA ENDS
ASSUME CS:CODE, DS:DATA
CODE SEGMENT
	START:
	    mov AX, DATA
    	mov ds, Ax
		MOV BX, X
CODE ENDS
END START
```

#### 寄存器间接寻址方式

物理地址 $\mathrm{=DS \times 16 + SI/BX/DI}$

```assembly
MOV AX，[SI]
```

#### 寄存器相对寻址方式

物理地址 $\mathrm{=DS \times 16 + SI/BX/DI + DISP}$

```assembly
MOV AX，3000H[SI]	; 写法一
MOV AX，3000H+[SI]	; 写法二
MOV AX，[3000H+SI]	; 写法三
MOV AX，COUNT[SI]	; 写法四，这里有 `COUNT  EQU  3000H`
```



#### 基址加变址寻址方式

物理地址 $= \mathrm{DS ×16 + BX + SI（ 或DI）}$

```assembly
MOV AX，[BX][DI]
```

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230628200717164.png" alt="image-20230628200717164" style="zoom:50%;" />

#### 相对基址加变址寻址方式

物理地址 $\mathrm{= DS ×16 + BX + SI（或 DI） + disp}$

```assembly
MOV AX，disp[BX][SI]		; 写法一
MOV AX，[BX+SI]+disp		; 写法二
MOV AX，[BX+SI+disp]		; 写法三
```

### 与转移地址有关的寻址方式

无条件转移指令格式：           

```assembly
JMP  目标地址
```

#### 段内间接寻址方式

【例】假设  DS=1000H; BX =1234H ; SI=0567H; DATA1（位移量）=30A1H，存储器单元（11234H）=9876H，（1483CH）=0AABBH。当执行

（1）JMP BX后IP的值是多少？            

（2）JMP WORD PTR [BX] 后IP的值是多少？            

（3）JMP DATA1[BX][SI]后IP的值是多少？ 

【解】

（1）执行JMP BX后，IP = BX =1234H           ；寄存器BX中的值就是转移的地址

（2）执行JMP WORD PTR  [BX]        

​		  有效地址EA=（11234H）=9876H      

 		 IP =9876H；存储器中的值就是转移的地址

（3）执行   JMP DATA1[BX\][SI]

​		  执行完该指令：

​		  EA  =（  DS*16+ BX + SI + DATA1）      

​				=（10000H +1234H + 0567H + 30A1H  ）    

​				=（1483CH）=0AABBH  

​		   所以： IP =0AABBH  内存地址为（1483CH）单元所指的内容为0AABBH，即为IP的转移偏移地址，是段内存储器间接转移。



#### 段间直接寻址

```assembly
JMP   标号
```



### 指令大全

#### 数据传送指令

##### MOV

- 指令格式：  MOV  DST，SRC
  - DST：**目的操作数**。可以是存储器、寄存器（CS除外）操作数；            
  - SRC：**源操作数**。可以是立即数、存储器 、寄存器（包括CS）操作数
- 执行操作：DST ←  SRC
- 指令功能：把一个字节或字或双字从源操作数送目的操作数。
- 注意事项：
  1. DST和SRC必须相同位数。例如：`MOV AL，BL` 
  2. CS段寄存器不能为目的操作数
  3. 立即数不能为目的操作数

##### PUSH

- 指令格式：PUSH SRC
  - SRC: **源操作数**。可以是通用寄存器、段寄存器、存储器、立即数。
- 执行操作：(SP) ←  SRC，然后 SP ← SP - 2 (对于16位) 或 SP ← SP - 4 (对于32位)
- 指令功能：将源操作数（一个字或双字）压入堆栈顶部。
- 注意事项：
  1. 不同于其他指令，PUSH可以接受立即数作为操作数。
  2. 指令会修改堆栈指针 SP。

【例】设AX=1234H，SP=0100H，请画出执行PUSH  AX前后的堆栈图，执行这条指令后SP=？

【解】执行步骤：SP=SP-2；[SP+1，SP] ←AX

![image-20230628201942613](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230628201942613.png)



##### POP

- 指令格式：POP DST
  - DST: **目标操作数**。可以是寄存器、存储器、段寄存器（除CS以外）。
- 执行操作：DST ← (SP)，然后 SP ← SP + 1 (对于16位) 或 SP ← SP + 2 (对于32位)
- 指令功能：从堆栈顶部弹出一个字或双字到目标操作数。
- 注意事项：
  1. 立即数不能为目标操作数。
  2. 指令会修改堆栈指针 SP。
  3. 不能从空堆栈中弹出数据，这将会导致未定义的行为。



##### XCHG

- 指令格式：XCHG DST, SRC
  - DST：**目的操作数**。可以是存储器、寄存器操作数；            
  - SRC：**源操作数**。只能是寄存器操作数。
- 执行操作：DST ↔ SRC
- 指令功能：交换源操作数和目的操作数的内容。
- 注意事项：
  1. DST和SRC必须相同位数。例如：`XCHG AX, BX`
  2. 两个操作数不能同时为存储器地址。例如，`XCHG [BX], [SI]` 是不允许的。
  3. 不允许立即数作为任何操作数。例如，`XCHG AX, 4` 是不允许的。



##### XLAT

- 指令格式： XLAT  [SCR]

- 执行操作： AL←[BX+AL]

- 指令功能：在换码表中找到一个值（字节）送AL；这个值的地址为BX+AL。BX中是换码表的首地址，AL中是所找的值相对于换码表首地址的相对值。

  ```assembly
  MOV AL，4     		; 要找的字节序号送AL中                          
  MOV BX，OFFSET S-TAB ; 将S-TAB的偏移地址送BX        
  XLAT  S-TAB    		; 取值
  ```

  ![image-20230703160108362](https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230703160108362.png)

  执行后，AL=0FFH

  





#### 地址传送指令

##### LEA

- 指令格式：LEA DST, SRC

  - DST：**目的操作数**。只能是寄存器操作数；
  - SRC：**源操作数**。应该是一个有效的内存地址表达式。

- 执行操作：DST ← 地址(SRC)

- 指令功能：把源操作数（一个有效的内存地址表达式）的地址加载到目的操作数（寄存器）中。

- 注意事项：

  1. SRC操作数是一个内存地址表达式，而不是存储在该地址的值。例如，如果SRC是[BX+SI]，那么LEA会把BX+SI的结果加载到DST，而不是加载存储在[BX+SI]的值。
  2. 不允许立即数作为任何操作数。例如，`LEA AX, 4` 是不允许的。
  3. DST操作数必须是一个寄存器。例如，`LEA [BX], [SI]` 是不允许的。

- 例：LEA BX, [BX+SI+0F62H]；其中BX=0400H, SI=003CH

  执行指令后：BX=0400H+003CH+0F62H=139EH





#### 标志寄存器传送指令

> 暂时略

#### 算术运算指令

<img src="https://melody0v0.oss-cn-beijing.aliyuncs.com/MarkdownPic/image-20230628203626380.png" alt="image-20230628203626380" style="zoom:67%;" />

运算的结果会影响标志寄存器：ZF，SF，CF，OF

1. 零标志（ZF）：当运算结果为0时，ZF 将被置1。

2. 符号标志（SF）：当运算结果为负数时，SF 将被置1

3. 进位标志（CF）：此标志用于表示无符号整数运算的进位或借位。在加法中，如果结果大于当前位宽所能表示的最大无符号数，CF被设置；在减法中，如果被减数小于减数，CF也被设置。

4. 溢出标志（OF）：当运算结果溢出时，OF将被置1。

这些标志位在控制流（如条件跳转）和某些算术运算中起着关键作用。例如，乘法和除法指令可能会检查CF和OF，以确定是否发生溢出；条件跳转指令（如JZ，JNZ，JS，JNS等）会检查ZF和SF，以确定是否满足跳转条件。



##### MUL

- 指令格式：MUL SRC
  - SRC：**源操作数**。可以是寄存器或内存单元。
- 执行操作：AX ← AL * SRC（字节操作数） 或者 DX:AX ← AX * SRC（字操作数）
- 指令功能：将源操作数与AL（字节操作数）或AX（字操作数）相乘，并将结果存储在AX（字节操作数）或DX:AX（字操作数）中。
- 注意事项：
  1. MUL不接受两个显式操作数。它隐式地使用AL或AX作为一个操作数。
  2. 如果乘法结果不能被存放在指定的寄存器中（即，如果字节操作数的结果超过了255，或者字操作数的结果超过了65535），则CF和OF会被设置。

##### DIV

- 指令格式：DIV SRC
  - SRC：**源操作数**。可以是寄存器或内存单元。
- 执行操作：AL ← AX / SRC，AH ← AX % SRC（字节操作数）或者 AX ← DX:AX / SRC，DX ← DX:AX % SRC（字操作数）
- 指令功能：将AX（字节操作数）或DX:AX（字操作数）除以源操作数，然后将商存储在AL（字节操作数）或AX（字操作数）中，余数在AH（字节操作数）或DX（字操作数）中。
- 注意事项：
  1. DIV不接受两个显式操作数。它隐式地使用AX或DX:AX作为被除数。
  2. 如果商大于寄存器可以存储的最大值（即，如果字节操作数的商大于255，或者字操作数的商大于65535），则会触发除法溢出异常（#DE）。在这种情况下，CF、OF、SF、ZF和PF的值都是未定义的。



`MUL/DIV` 的工作方式根据操作数的大小会有所不同：

1. **8位操作数：** 如果 `source` 是一个8位操作数，那么被除数将是16位的 `AX `寄存器，商会存储在 `AL  `寄存器中，余数会存储在 `AH ` 寄存器中。
2. **16位操作数：** 如果 `source` 是一个16位操作数，那么被除数将是32位的 `DX:AX` ，这表示 `DX ` 和 `AX ` 寄存器会被视为一个32位的数值，其中 `DX` 保存高16位，`AX` 保存低16位。商会存储在 `AX` 寄存器中，余数会存储在 `DX` 寄存器中。



#### 移位指令

移位指令是一种二进制位操作指令，用于将寄存器或内存中的位值向左或向右移动指定的位数。

- **逻辑左移（SHL）** 和 **算术左移（SAL）**：将指定操作数中的位向左移动指定的位数，空出的右侧位用0填充。对于SHL和SAL，它们在大多数硬件和编程语言中都是等效的。
- **逻辑右移（SHR）**：将指定操作数中的位向右移动指定的位数，空出的左侧位用0填充。
- **算术右移（SAR）**：将指定操作数中的位向右移动指定的位数，空出的左侧位用原来最高位的值填充（如果原来的最高位是1，则用1填充，如果是0，则用0填充）。这种方式保持了负数的符号不变。
- **循环左移（ROL）** 和 **循环右移（ROR）**：将指定操作数中的位向左或向右移动指定的位数，被移出的位将填充到空出的位上。
- **带进位循环左移（RCL）** 和 **带进位循环右移（RCR）**：和ROL和ROR类似，但是它们在移位的同时，会考虑进位标志（CF）的值，并会影响进位标志的状态。

> 8086中COUNT=1或=CL（移位位数大于1位时，先送CL 中）



## 第四部分

#### 完整段定义框架

```assembly
STACK   SEGMENT   ; 定义堆栈段
           ┇
STACK    ENDS

DATA    SEGMENT   ; 定义数据段
           ┇
DATA    ENDS

CODE  SEGMENT     ; 定义代码段
    ASSUME  CS：CODE，DS：DATA，SS：STACK 
    ; 说明代码段的段地址放在CS中
    ; 数据段的段地址放在DS中
    ; 堆栈段的段地址放在SS中
    START:
    	; 主程序...
CODE  ENDS        ;代码段结束
END  START


```



#### 定义数据的指令

DB、DW、DD是在8086汇编语言中用于定义数据的指令，分别代表"定义字节"（Define Byte）、"定义字"（Define Word）和"定义双字"（Define Doubleword）。

1. **DB**：用于定义一个字节大小的数据（8位）。例如：
   - `DB 10`：定义一个字节，其值为10。
   - `DB 'A'`：定义一个字节，其值为字符'A'的ASCII值。

2. **DW**：用于定义一个字大小的数据（16位）。例如：
   - `DW 1000`：定义一个字，其值为1000。
   - `DW 'AB'`：定义一个字，其值为字符'A'和'B'的ASCII值组成的16位值。

3. **DD**：用于定义一个双字大小的数据（32位）。例如：
   - `DD 100000`：定义一个双字，其值为100000。



#### 当前位置计数器（$）

当前位置计数器（$）表示当前的偏移值

【例】下列指令是在数据段中定义的，画出其内存中的存储结构，并计算出符号常量LEN1和LEN2的值。        

```assembly
X1    DB  1，2，3，5          
LEN1  EQU $-X1          
X2    DW  1234H        
LEN2  EQU $-X2
```

 【解】假设X1地址为2000H，LEN为符号常量，不占存储空间，X2为字变量，则X2的地址为2004H。

LEN1的值是\$-X1=2004H-2000H=0004H，数组X1的长度为4字节。

LEN2的值是$-X2=2006H-2004H=0002H，变量X2的长度为2字节。

#### 设置内存空间表达式（?）

“？”表示预留该位置，但没有为该存储空间赋初值。

```assembly
X2   DW  ？，100，－5
```

#### 



#### 常见操作符

##### DUP

在8086汇编语言中，DUP是一个伪指令，用于在数据段定义重复的数据元素。DUP常常和DB、DW、DD等数据定义指令一起使用，表示重复某个数据项的特定次数。

以下是一些使用DUP的例子：

1. `DB 10 DUP(0)`：这会在数据段中定义10个字节，每个字节的值都是0。

2. `DW 5 DUP(300)`：这会在数据段中定义5个字，每个字的值都是300。

3. `DB 4 DUP('A')`：这会在数据段中定义4个字节，每个字节的值都是字符'A'的ASCII值。

4. `DB 3 DUP(?)`：这会在数据段中定义3个字节，但是并不初始化这些字节的值。这种情况下，这些字节的初始值是未定义的。

DUP也可以用于定义一个重复的数据模式，例如`DB 3 DUP('A', 'B', 'C')`将在数据段中定义一个字符串`'ABCABCABC'`。

请注意，DUP定义的数据元素在编译时就固定下来，不能在运行时改变。如果你需要在运行时创建或修改重复的数据元素，你需要使用其他的方法，例如使用循环结构和赋值指令。



#### 标号

标号是用来说明可执行指令在汇编语言程序中的位置

```assembly
LP1：
	MOV AX，X
         …  
JMP  LP1   ；转移到标号LP1处的指令

```



#### 数值回送操作符

在8086汇编语言中，一种常见的数值回送操作符是 `OFFSET` 。`OFFSET` 操作符用于获取变量在内存中的地址，而不是其值。在编程中，有时我们需要知道一个变量的地址，而不仅仅是它的值。例如，我们可能需要传递一个变量的地址给一个过程，这样过程就可以修改这个地址处的值。

以下是一些使用 `OFFSET` 的例子：

1. `MOV AX, OFFSET var`：将变量var的地址加载到寄存器AX中。注意这里AX得到的是地址，而不是var的值。

2. `MOV DS, OFFSET dataArray`：将dataArray数组的地址加载到数据段寄存器DS中。之后可以通过使用BX、SI或DI寄存器作为偏移量来访问数组的元素。

3. `LEA BX, var`：使用LEA（Load Effective Address）指令将var的地址加载到BX寄存器中。虽然LEA指令的功能类似于使用OFFSET，但LEA可以计算更复杂的地址表达式，比如基于其他寄存器的偏移。



除了 `OFFSET` 以外，还有其他数值回送操作符

- SEG（取段地址）

  - 操作符格式：    SEG   变量名/标号 
  - 操作符功能：取变量或标号的段基值（段地址）

- TYPE  （取类型值） 

  - 操作符格式：    TYPE   变量名/ 标号 
  - 功能：取变量或标号的类型值。（字节=1、字=2、双字=4等，NEAR=-1，FAR=-2）

- LENGTH （取长度）

  - 操作符格式：    LENGTH   变量名
  - 功能：取分配给变量的字节、字、双字等的个数（说明：只有用DUP重复定义的变量才有意义，否则=1。）

- SIZE  （取总字节数）

  - 操作符格式： SIZE  变量名

  - 操作符功能：SIZE 给出一个变量的总字节数(也就是LENGTH 和TYPE的乘积),即：SIZE=LENGTH ×TYPE



#### 属性操作符

PTR是一种类型转换操作符，用于显示地指定操作数的类型。PTR操作符后面通常跟着BYTE PTR、WORD PTR或者DWORD PTR，来指明操作数应该被视为一个字节、一个字或一个双字。

【例】在数据段定义：

```assembly
X  DB  ‘A’
Y  DW   1234H
Z  DD   12345678H      …
```

在代码段中：

```assembly
MOV  AX，Y            	;类型匹配，正确此时AX=1234H
MOV  BL， BYTE  PTR  Y 	;用PTR取出Y变量中的一个字节，BL=34H
MOV  CL， BYTE  PTR  Y+1	;用PTR取出Y变量中的一个字节，CL=12H
MOV  DL，BYTE  PTR Z+3 	;将Z+3所指的字节内容送DL中，DL=12H
```





## 第五部分

### 转移指令

#### CMP与跳转指令

`CMP` 是比较指令，用于比较两个值。并根据比较结果设置处理器的状态标志。如果结果显示 `参数1` 的值【条件】 `参数2` 的值，则设置处理器的状态标志

以 `JAE` 为例，他的含义是"**不小于跳转**" 当 `参数1` 的值大于等于 `参数2` 的值时将跳转。

以下是一些与 `CMP` 指令相关的常用条件跳转指令：

- `JE`（Jump if Equal）：如果比较结果为相等，则跳转。
- `JNE`（Jump if Not Equal）：如果比较结果为不相等，则跳转。
- `JG`（Jump if Greater）：如果比较结果为大于，则跳转。
- `JGE`（Jump if Greater or Equal）：如果比较结果为大于或等于，则跳转。
- `JL`（Jump if Less）：如果比较结果为小于，则跳转。
- `JLE`（Jump if Less or Equal）：如果比较结果为小于或等于，则跳转。
- `JA`（Jump if Above）：如果无符号数比较结果为大于，则跳转。
- `JAE`（Jump if Above or Equal）：如果无符号数比较结果为大于或等于，则跳转。
- `JB`（Jump if Below）：如果无符号数比较结果为小于，则跳转。
- `JBE`（Jump if Below or Equal）：如果无符号数比较结果为小于或等于，则跳转。





#### 功能号与int中断指令

`int 21h` 是一个软件中断指令，用于调用DOS（Disk Operating System）功能。通过在`ah`寄存器中设置特定的功能号，可以使用`int 21h`来执行各种与DOS相关的操作。下面列一些 `int 21h` 调用的含义和作用：

1. - `int 21h`，功能号`00h`：
     - 含义：程序终止。
     - 作用：终止程序的执行。
   - `int 21h`，功能号`01h`：
     - 含义：从标准输入获取一个字符。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中。
   - `int 21h`，功能号`02h`：
     - 含义：将字符输出到标准输出。
     - 作用：将`dl`寄存器中的字符显示在屏幕上。
   - `int 21h`，功能号`06h`：
     - 含义：将字符输出到标准输出（无回显）。
     - 作用：将`dl`寄存器中的字符显示在屏幕上，但不在屏幕上显示光标。
   - `int 21h`，功能号`08h`：
     - 含义：从标准输入获取一个字符（无回显）。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，但不在屏幕上显示字符。
   - `int 21h`，功能号`09h`：
     - 含义：显示字符串。
     - 作用：将存储在`dx`寄存器指向的字符串输出到屏幕上。
   - `int 21h`，功能号`0Ah`：
     - 含义：从标准输入获取一个字符并缓冲。
     - 作用：等待用户从键盘输入一个字符，并将其存储在`al`寄存器中，同时将其缓冲以供后续读取。
   - `int 21h`，功能号`0Ch`：
     - 含义：获取当前打印页号。
     - 作用：将当前打印页号存储在`al`寄存器中。

#### 常用功能号

| AH   | 描述                               |
| ---- | ---------------------------------- |
| 00h  | 程序终止                           |
| 01h  | 从标准输入获取一个字符             |
| 02h  | 将字符输出到标准输出               |
| 06h  | 将字符输出到标准输出（无回显）     |
| 08h  | 从标准输入获取一个字符（无回显）   |
| 09h  | 显示字符串                         |
| 0Ah  | 从标准输入获取一个字符并缓冲       |
| 0Ch  | 获取当前打印页号                   |
| 0Eh  | 将字符输出到标准输出并保留光标位置 |
| 25h  | 设置DOS版本号                      |
| 2Ch  | 获取系统时间                       |
| 30h  | 获取DOS版本号                      |
| 33h  | 设置断点                           |
| 35h  | 获取磁盘参数                       |
| 3Dh  | 打开文件                           |
| 3Eh  | 关闭文件                           |
| 3Fh  | 读取文件                           |
| 40h  | 写入文件                           |
| 4Bh  | 加载和执行程序                     |
| 4Ch  | 程序终止，并返回错误级别           |



### 循环控制指令

#### LOOP

- 操作符格式：    LOOP   标号 
- 操作符功能：CX ← CX-1 。CX≠0则转到到标号所指的指令，执行循环体;否则退出循环，顺序执行LOOP指令下面的指令。