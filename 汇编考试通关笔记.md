汇编考试通关笔记

<p align="right"><i><font color=#0000FF> ——made by njtech_计2104 Melody</font></i></p>



## 考纲

考试题型涉及：选择题、简答题、程序分析题、程序设计题

- 第一部分：字符的表示方法、汇编语言源程序与汇编语言
- 第二部分：物理地址、段地址、段内地址和逻辑地址、标志寄存器、段寄存器(CS、 DS、SS、ES)
- 第三部分：寄存器间接寻址方式、数据传送指令、基址变址寻址方式、算术运算指令、逻辑操作指令、有效地址传送指令（LEA）、算术运算指令、寻址方式
- 第四部分：变量、数值回送操作符、重复定义操作符(DUP)、属性操作符、 常量
- 第五部分：条件转移指令、比较指令CMP、比较指令、循环控制指令
- 第六部分：子程序的编程原则、参数的传递、子程序的调用与返回指令
- 第七部分：宏与子程序的区别、宏内局部标号定义伪指令、重复汇编、条件汇编
- 第八部分： I/O指令、 设置中断向量获取中断向量、 中断向量表、中断过程、键盘IO程序设计
- 其它部分：Debug指令



## 第一部分

### 字符的表示方法

当涉及到字符的表示方法时，**ASCII编码**是一个重要的概念。ASCII（American Standard Code for Information Interchange）是一种用于将字符映射为数字代码的标准编码系统。在计算机中，每个字符都被赋予一个唯一的ASCII码。

在8086处理器中，ASCII码通常以一个字节的形式表示。一个字节可以存储8个二进制位，在标准ASCII中，其最高位（b7）用作**奇偶校验位**，因此ASCLL码可以表示128个字符（在计算机中为0~127）
$$
2^7=128
$$

> 所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。
>
> - 奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；
> - 偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1
>
> $$
> \begin{array}{c|c|c}
> \hline \text { 信息位 } &  \text { 采用奇校验的校验位 } & \text { 采用偶校验的校验位 }  \\
> \hline 1\space 0\space 0\space 1\space 1\space 0\space 1 & 1 & 0 \\
> \end{array}
> $$

可以通过查找ASCII码表来获取字符的对应值。

![image-20230629161610132](http://124.221.95.230:9001/markdown/imgs/image-20230629161610132.png)

其中，有一些必须要记的ASCLL码：

| ASCLL 码 | 对应字符 |
| -------- | -------- |
| 48       | 0        |
| 65       | A        |
| 97       | a        |

利用这三个常用ASCLL码，可以计算其他常见ASCLL码，例如：

1. “6”的ASCLL码为 $48+6 =54$
2. "C"的ASCLL码为 $65+2=67$（以A为0，则C为第“2”个）
3. “e”的ASCLL码为 $97+4=101$

在汇编语言中，可以使用ASCII码来表示字符。字符常量可以用单引号括起来，例如：

```assembly
MOV AL, 'A'  ; 将ASCII码为65的字符'A'移动到AL寄存器中
```



### 汇编语言源程序与汇编语言

用汇编语言书写的程序称为汇编语言源程序，汇编语言源程序是在编辑程序中形成的。编辑、汇编与连接过程如下：

![image-20230629163809270](http://124.221.95.230:9001/markdown/imgs/image-20230629163809270.png)

## 第二部分



### 段地址

将1MB的内存空间分成长为64K字节的段，每个段用1个16位二进制地址表示。

### 偏移地址（段内地址）

16位二进制段内地址为偏移地址不同段内的偏移地址是存放在不同的寄存器中

### 物理地址

与内存单元一一对应的20位2进制（或5位16进制）表示的地址为物理地址
$$
\mathrm{ 1MB=00000H  -  FFFFFH}
$$
每个物理地址代表一个唯一的内存单元。

一个完整的物理地址是由一个16位的段地址和一个16位的偏移地址组合而成的。具体的计算方式是：将段地址左移4位（也就是乘以16，或者说乘以十六进制的1000h），然后再加上偏移地址。这种方式允许我们从两个16位的值生成一个20位的物理地址。

对于段地址和偏移地址，我的理解是真的只是为了定义而起了两个名字，没有什么特殊的含义，你只需要知道，在计算机的表示格式为“段地址：偏移地址”即可。

> 在表示地址中，尽管寄存器为16位，但并不会以"0000 0000 0000 0000 "来表示，因为这样太长且不利于阅读，因此采用16进制来表示，比如："1011 1000 1111 0001" 对应的16进制数为"B8F1" ，

以“1234:1234” 地址为例，他的20位地址计算图如下：

<img src="http://124.221.95.230:9001/markdown/imgs/image-20230521174417254.png" alt="image-20230521174417254" style="zoom:67%;" />

### 逻辑地址

用段地址和偏移地址来表示内存单元的地址为逻辑地址，两地址之间用“：”隔开。常写成：   段地址：偏移地址。

例如： 物理地址为00001H，逻辑地址为 `0000H：0001H` ，段地址为0000H ， 段内地址为0001H。

### 标志寄存器

| 符号 | 名称               | 标志位状态             | 功  能                                                       |
| ---- | ------------------ | ---------------------- | ------------------------------------------------------------ |
| CF   | 进位标志           | CF=1；CY<br />CF=0；NC | CF=1运算结果最高位有进位或有借位（用于多字节加减运算）否则CF=0。 （DEBUG中 CF=1：CY，CF=0：NC） |
| PF   | 奇偶标志           | PF=1；PE<br />PF=0；PO | 运算结果的低8位中所含“1”的个数为偶数：PF=1，否则PF=0。（DEBUG中 PF=1：PE，PF=0：PO） |
| AF   | 辅助进位标志       | AF=1；AC<br />AF=0；NA | AF=1：运算结果低四位向高四位有进位或有借位（用于10进制运算指令）否则AF=0 。 （DEBUG中 AF=1：AC，AF=0：NA） |
| ZF   | 结果为0标志        | ZF=1；ZR<br />ZF=0；NZ | ZF=1运算结果为0，ZF=0运算结果不为0；（DEBUG中 ZF=1：ZR，ZF=0：NZ） |
| SF   | 符号标志           | SF=1；NG<br />SF=0；PL | 运算结果为正（符号位为0）SF=0； 运算结果为负（符号位为1）SF=1。（DEBUG中 SF=1：NG，SF=0：PL） |
| OF   | 溢出标志           | OF=1；OV<br />OF=0；NV | 带符号数的运算结果产生溢出时，OF=1；否则OF=0 。（DEBUG中 OF= 1：OV，OF=0：NV） |
| DF   | 方向标志           | DF=1；DN<br />DF=0；UP | 串操作指令用的标志，DF=1执行字符串操作指令时使地址指针自动增量（字符串处理顺序由低向高进行）；DF=0使地址指令自动减量。可通过指令STD置DF =1，CLD清DF =0（DEBUG中 DF=1：DN，DF=0：OP） |
| IF   | 中断标志           | IF=1；EI<br />IF=0；DI | 可屏蔽中断的标志；IF=1允许中断（允许CPU响应可屏蔽外部中断）；IF=0禁止中断，关中断；可通过指令STI置IF=1，CLI清IF=0（DEBUG中 IF=1；EI，IF=0；DI） |
| TF   | TF单步（跟踪）标志 | TF=1<br />TF=0         | CPU按单步跟踪方式执行指令                                    |

### 段寄存器(CS、 DS、SS、ES)

#### CS（代码段寄存器）

在8086处理器中，CS（代码段）寄存器是一个16位的寄存器，它被用于保存当前正在执行的代码段的基地址。在分段内存管理模型中，整个内存被划分为多个段，每个段有一个基地址和一个长度。段寄存器（例如CS）存储着相应段的基地址，而内存中的具体位置则由段寄存器和一个偏移地址共同决定。

例如，如果CS的值是1234h，IP（指令指针）寄存器的值是5678h，那么处理器会在物理内存地址12340h + 5678h = 179B8h处查找下一条要执行的指令。注意这里的地址计算是通过将CS的值左移4位（或乘以16）然后加上IP的值得到的。

CS寄存器的值通常在以下情况下改变：

- 当执行一个跳转或调用指令到一个新的代码段时，CS的值会被更新为新的代码段的地址。
- 当发生中断或异常时，处理器会自动保存当前的CS和IP的值，然后加载新的CS和IP的值来处理中断或异常。

注意，由于CS寄存器用于保存代码段地址，所以在大多数情况下，程序员不能直接修改它的值。CS寄存器的值通常在跳转、调用、返回、中断或异常处理等操作中被隐式地改变。

以下是一些使用CS寄存器的示例：

```assembly
JMP 1234h:5678h ; 跳转到物理地址12340h + 5678h处执行代码，CS被设置为1234h，IP被设置为5678h

CALL 1234h:5678h ; 调用位于物理地址12340h + 5678h处的过程，CS被设置为1234h，IP被设置为5678h

; 在中断服务例程中，处理器会自动保存CS和IP的值，然后加载新的CS和IP的值
```



#### DS（数据段寄存器）

在8086微处理器中，DS（数据段）寄存器是一个16位的寄存器，它被用于保存当前数据段的基地址。数据段通常是存储程序数据（如变量和常量）的地方。

在分段内存管理模型中，整个内存被划分为多个段，每个段有一个基地址和一个长度。段寄存器（例如DS）存储着相应段的基地址，而内存中的具体位置则由段寄存器和一个偏移地址共同决定。

例如，如果DS的值是1234h，BX（基址寄存器）的值是5678h，那么处理器会在物理内存地址12340h + 5678h = 179B8h处查找或存储数据。注意这里的地址计算是通过将DS的值左移4位（或乘以16）然后加上BX的值得到的。

DS寄存器的值通常在以下情况下改变：

- 当程序需要访问一个新的数据段时，DS的值需要被更新为新的数据段的地址。

以下是一些使用DS寄存器的示例：

```assembly
MOV AX, 1234h   ; 将1234h（十六进制数）移动到AX寄存器
MOV DS, AX      ; 将AX寄存器的值移动到DS寄存器，设置数据段的基地址

MOV BX, 5678h   ; 将5678h（十六进制数）移动到BX寄存器，设置偏移地址
MOV AL, [BX]    ; 从物理地址12340h + 5678h处读取一个字节到AL寄存器

MOV [BX], AL    ; 将AL寄存器的值写入到物理地址12340h + 5678h处
```

> 这里的 `mov ax, 1234h` 和 `mov ds, ax` 的用法是由8086处理器的硬件设计和汇编语言的语法规则决定的。
>
> 首先，`1234h` 是一个立即数，在这里可以假设其代表了数据段在内存中的起始地址。
>
> 在8086处理器的架构中，一些特殊的寄存器，如段寄存器（包括 DS），由于它们的特殊用途，对于它们能接受的操作和数据有一定的限制。在这种情况下，不能直接将一个立即数加载到段寄存器中，所以不能直接执行 `mov ds, 1234h` 这样的操作。
>
> 因此，为了将数据段的地址加载到 DS 寄存器，需要先将地址加载到一个通用寄存器（ AX）中，然后再将该通用寄存器的值（寄存器操作数）加载到 DS 寄存器中。这就是为什么需要 `mov ax, 1234h` 和 `mov ds, ax` 这两步操作的原因。
>
> 这样的设计可能会让人感到有些繁琐，但它也反映出了早期微处理器设计的一些历史和技术背景，以及在有限的硬件资源和复杂性之间寻找平衡的结果。
>
> 关于立即数的概念，详见[操作数](#操作数)

#### SS（堆栈段寄存器）

在8086微处理器中，SS（堆栈段）寄存器是一个16位的寄存器，它被用于保存当前堆栈段的基地址。堆栈是一种特殊的数据结构，其特性是后进先出（Last-In-First-Out，LIFO）。在程序中，堆栈常被用于存储局部变量、函数参数、返回地址等信息。

#### ES（附加段寄存器）



## 第三部分



### 数据传送指令

#### MOV

- 指令格式：  MOV  DST，SRC
  - DST：**目的操作数**。可以是存储器、寄存器（CS除外）操作数；            
  - SRC：**源操作数**。可以是立即数、存储器 、寄存器（包括CS）操作数
- 执行操作：DST ←  SRC
- 指令功能：把一个字节或字或双字从源操作数送目的操作数。
- 注意事项：
  1. DST和SRC必须相同位数。例如：`MOV AL，BL` 
  2. CS段寄存器不能为目的操作数
  3. 立即数不能为目的操作数

#### PUSH

- 指令格式：PUSH SRC
  - SRC: **源操作数**。可以是通用寄存器、段寄存器、存储器、立即数。
- 执行操作：(SP) ←  SRC，然后 SP ← SP - 2 (对于16位) 或 SP ← SP - 4 (对于32位)
- 指令功能：将源操作数（一个字或双字）压入堆栈顶部。
- 注意事项：
  1. 不同于其他指令，PUSH可以接受立即数作为操作数。
  2. 指令会修改堆栈指针 SP。

【例】设AX=1234H，SP=0100H，请画出执行PUSH  AX前后的堆栈图，执行这条指令后SP=？

【解】执行步骤：SP=SP-2；                    [SP+1，SP] ←AX

![image-20230628201942613](http://124.221.95.230:9001/markdown/imgs/image-20230628201942613.png)



#### XCHG

- 指令格式：XCHG DST, SRC
  - DST：**目的操作数**。可以是存储器、寄存器操作数；            
  - SRC：**源操作数**。只能是寄存器操作数。
- 执行操作：DST ↔ SRC
- 指令功能：交换源操作数和目的操作数的内容。
- 注意事项：
  1. DST和SRC必须相同位数。例如：`XCHG AX, BX`
  2. 两个操作数不能同时为存储器地址。例如，`XCHG [BX], [SI]` 是不允许的。
  3. 不允许立即数作为任何操作数。例如，`XCHG AX, 4` 是不允许的。





#### POP

- 指令格式：POP DST
  - DST: **目标操作数**。可以是寄存器、存储器、段寄存器（除CS以外）。
- 执行操作：DST ← (SP)，然后 SP ← SP + 1 (对于16位) 或 SP ← SP + 2 (对于32位)
- 指令功能：从堆栈顶部弹出一个字或双字到目标操作数。
- 注意事项：
  1. 立即数不能为目标操作数。
  2. 指令会修改堆栈指针 SP。
  3. 不能从空堆栈中弹出数据，这将会导致未定义的行为。



### 算术运算指令



运算的结果会影响标志寄存器：ZF，SF，CF，OF

1. 零标志（ZF）：当运算结果为0时，此标志被设置。例如，如果两个相等的数相减（比如3-3），结果为0，那么ZF将被置1。

2. 符号标志（SF）：此标志反映了结果的符号。在二进制表示中，最高位被用作符号位。如果最高位是1，那么结果被认为是负的，并且SF被设置。例如，如果执行一个减法操作，如5-7，结果是-2（在补码表示中为11111110），SF将被置1。

3. 进位标志（CF）：此标志用于表示无符号整数运算的进位或借位。在加法中，如果结果大于当前位宽所能表示的最大无符号数，CF被设置；在减法中，如果被减数小于减数，CF也被设置。

4. 溢出标志（OF）：此标志用于表示有符号整数运算的溢出。如果结果大于当前位宽所能表示的最大有符号数，或者小于能表示的最小有符号数，那么OF被设置。例如，在一个8位系统中，如果试图将100（二进制为01100100）和100（二进制为01100100）相加，结果为200（二进制为11001000），由于最高位为1，会被误认为是负数，因此OF将被置1。

这些标志位在控制流（如条件跳转）和某些算术运算中起着关键作用。例如，乘法和除法指令可能会检查CF和OF，以确定是否发生溢出；条件跳转指令（如JZ，JNZ，JS，JNS等）会检查ZF和SF，以确定是否满足跳转条件。



##### MUL

- 指令格式：MUL SRC
  - SRC：**源操作数**。可以是寄存器或内存单元。
- 执行操作：AX ← AL * SRC（字节操作数） 或者 DX:AX ← AX * SRC（字操作数）
- 指令功能：将源操作数与AL（字节操作数）或AX（字操作数）相乘，并将结果存储在AX（字节操作数）或DX:AX（字操作数）中。
- 注意事项：
  1. MUL不接受两个显式操作数。它隐式地使用AL或AX作为一个操作数。
  2. 如果乘法结果不能被存放在指定的寄存器中（即，如果字节操作数的结果超过了255，或者字操作数的结果超过了65535），则CF和OF会被设置。

##### DIV

- 指令格式：DIV SRC
  - SRC：**源操作数**。可以是寄存器或内存单元。
- 执行操作：AL ← AX / SRC，AH ← AX % SRC（字节操作数）或者 AX ← DX:AX / SRC，DX ← DX:AX % SRC（字操作数）
- 指令功能：将AX（字节操作数）或DX:AX（字操作数）除以源操作数，然后将商存储在AL（字节操作数）或AX（字操作数）中，余数在AH（字节操作数）或DX（字操作数）中。
- 注意事项：
  1. DIV不接受两个显式操作数。它隐式地使用AX或DX:AX作为被除数。
  2. 如果商大于寄存器可以存储的最大值（即，如果字节操作数的商大于255，或者字操作数的商大于65535），则会触发除法溢出异常（#DE）。在这种情况下，CF、OF、SF、ZF和PF的值都是未定义的。



`MUL/DIV` 的工作方式根据操作数的大小会有所不同：

1. **8位操作数：** 如果 `source` 是一个8位操作数，那么被除数将是16位的 `AX `寄存器，商会存储在 `AL  `寄存器中，余数会存储在 `AH ` 寄存器中。
2. **16位操作数：** 如果 `source` 是一个16位操作数，那么被除数将是32位的 `DX:AX` ，这表示 `DX ` 和 `AX ` 寄存器会被视为一个32位的数值，其中 `DX` 保存高16位，`AX` 保存低16位。商会存储在 `AX` 寄存器中，余数会存储在 `DX` 寄存器中。



### 逻辑操作指令

#### 逻辑与（AND）

#### 逻辑或（OR）

#### 逻辑异或（XOR）

#### 逻辑非（NOT）

#### 测试（TEST） 



### 有效地址传送指令（LEA）

- 指令格式：LEA DST, SRC

  - DST：**目的操作数**。只能是寄存器操作数；
  - SRC：**源操作数**。应该是一个有效的内存地址表达式。

- 执行操作：DST ← 地址(SRC)

- 指令功能：把源操作数（一个有效的内存地址表达式）的地址加载到目的操作数（寄存器）中。

- 注意事项：

  1. SRC操作数是一个内存地址表达式，而不是存储在该地址的值。例如，如果SRC是[BX+SI]，那么LEA会把BX+SI的结果加载到DST，而不是加载存储在[BX+SI]的值。
  2. 不允许立即数作为任何操作数。例如，`LEA AX, 4` 是不允许的。
  3. DST操作数必须是一个寄存器。例如，`LEA [BX], [SI]` 是不允许的。

- 例：LEA BX, [BX+SI+0F62H]；其中BX=0400H, SI=003CH

  执行指令后：BX=0400H+003CH+0F62H=139EH

### 算术运算指令

### 寻址方式

#### 立即数寻址方式

立即数寻址方式就是8位、16位或32位常数直接出现在源操作数位置上。也就是立即数直接写在指令中。

```assembly
MOV AH,12H         	; 12H为字节立即数
MOV AX,1234H       	; 1234H为字立即数
MOV EAX,12345678H	; 12345678H为双字立即数
VALUE EQU 512		; 伪指令定义VALUE为符号常量512
```

#### 寄存器寻址方式

寄存器的内容就是指令运算的操作数，目的操作数和源操作数均可用寄存器存放。在指令中给出寄存器名。

设 				      AX =3066H，BX=1234H   

执行				   MOV AX，BX       

执行指令后    	AX =1234H                         BX =1234H

#### 直接寻址方式

> 相关知识点：[小端序](#小端序)

直接寻址方式指操作数在存储器的**数据段**（DS）中，该操作数的偏移地址（或有效地址EA）直接出现在指令中。直接寻址的格式为

```assembly
ds:[直接数]
```

为了方便使用，常常会在代码中加入 `ASSUME DS:DATA, CS:CODE` ，以略写前面的`ds:` 前缀

```assembly
mov AX,[2000H]
```

假设数据段地址DS=3000H，那么就能根据实模式的地址拼接方法可得：
$$
\mathrm{DS\times 16 + 2000H = 32000H}
$$
![image-20230628175857689](http://124.221.95.230:9001/markdown/imgs/image-20230628175857689.png)



#### 寄存器间接寻址

与直接寻址方式不同，间接寻址的意思是 `[]` 里面不是直接数而是寄存器

```assembly
mov ax,[BX]
```

其中方括号中只能是BX，BP和 SI，DI。



#### 寄存器相对寻址方式

操作数在存储器中，其地址是由：SI，DI，BX，BP之一与直接偏移地址（disp）相加组成。

> disp是8位位移量或16位位移量，也可以是符号常量或符号地址（变量）。

```assembly
MOV AX，3000H[SI]	; 写法一
MOV AX，3000H+[SI]	; 写法二
MOV AX，[3000H+SI]	; 写法三
MOV AX，COUNT[SI]	; 写法四，这个有 `COUNT  EQU  3000H`
```

形成物理地址为35000H



#### 基址变址寻址方式

有效地址EA是由两个寄存器内容相加组成。即：一个基址寄存器（BX或BP）的内容加上一个变址寄存器（SI，DI）的内容，与段寄存器（DS或SS）组合为操作数物理地址。
$$
物理地址= \mathrm{DS ×16 + BX + SI（ 或DI）}
$$


```assembly
MOV AX，[BX][DI]
```

假设：BX=3000H，DS=3000H，DI=1000H 则该指令的寻址方式和传送过程如图所示。

<img src="http://124.221.95.230:9001/markdown/imgs/image-20230628200717164.png" alt="image-20230628200717164" style="zoom:50%;" />

#### 相对基址变址寻址方式

把一个基址寄存器（BX，BP）的内容加上一个变址寄存器（SI，DI），再加上指令中8位或16位位移量与段寄存器（DS，SS）的组合为操作数地址。
$$
\mathrm{物理地址= DS ×16 + BX + SI（或 DI） + disp}
$$

```assembly
MOV AX，disp[BX][SI]		; 写法一
MOV AX，[BX+SI]+disp		; 写法二
MOV AX，[BX+SI+disp]		; 写法三
```



```assembly
MOV AX，[MASK+BX+SI] 
```

假设： BX=1000H，DS=3000H，SI=3000H，MASK=0250H

<img src="http://124.221.95.230:9001/markdown/imgs/image-20230628200926783.png" alt="image-20230628200926783" style="zoom:50%;" />



## 第四部分

### 变量

在汇编语言中，变量的概念并不像在高级编程语言中那么直观，但实际上变量在汇编语言中还是存在的。在8086汇编语言中，变量通常被表示为在内存中预留的一块区域，这个区域的大小和类型取决于变量的类型和用途。

首先我们要了解一点，8086处理器的汇编语言并**没有像C++或Java等高级语言中那样的内置变量类型**。所以，我们不能声明一个整数或者浮点数或者字符这样的变量类型。而是，我们在内存中预留了一块区域，并按照一定的方式解读这块区域中的内容，这就形成了我们的"变量"。

在8086汇编中，我们常用的是字节（BYTE）和字（WORD）这两种单位来分配变量的内存空间。

声明变量的格式是：`变量名 指定变量长度的助记符 操作数 `以下是一些例子：

1. 声明一个字节变量：

```assembly
    MYBYTE DB 0    ;定义一个字节变量MYBYTE，初值为0
```

这里，DB是一个汇编指令，它告诉编译器在内存中分配一块大小为一个字节的区域，用于存放变量MYBYTE的值。0是这个变量的初始值。

对于操作数，有如下性质：

- 可以是数字常量、字符常量、字符串常量、符号常量、数值表达式、地址表达式、？、[n] DUP [操作数]等
- 可以包含0个、一个或多个操作数，多个操作数之间以逗号(，)分隔

```assembly
X1   DB  10，0，10H
X2   DW  ？，100，－5
X3   DD  5*20+5 ，0ABCDEF68H

```

#### 当前位置计数器（$）

当前位置计数器（$）表示当前的偏移值

【例】下列指令是在数据段中定义的，画出其内存中的存储结构，并计算出符号常量LEN1和LEN2的值。        

```assembly
X1    DB  1，2，3，5          
LEN1  EQU $-X1          
X2    DW  1234H        
LEN2  EQU $-X2
```

 【解】假设X1地址为2000H，LEN为符号常量，不占存储空间，X2为字变量，则X2的地址为2004H。

LEN1的值是\$-X1=2004H-2000H=0004H，数组X1的长度为4字节。

LEN2的值是$-X2=2006H-2004H=0002H，变量X2的长度为2字节。

#### 设置内存空间表达式（?）

“？”表示没有为该存储空间赋初值，汇编后该存储空间清零。

```assembly
X2   DW  ？，100，－5
```

#### 重复定义操作符(DUP)

在8086汇编语言中，DUP是一个伪指令，用于在数据段定义重复的数据元素。DUP常常和DB、DW、DD等数据定义指令一起使用，表示重复某个数据项的特定次数。

以下是一些使用DUP的例子：

1. `DB 10 DUP(0)`：这会在数据段中定义10个字节，每个字节的值都是0。

2. `DW 5 DUP(300)`：这会在数据段中定义5个字，每个字的值都是300。

3. `DB 4 DUP('A')`：这会在数据段中定义4个字节，每个字节的值都是字符'A'的ASCII值。

4. `DB 3 DUP(?)`：这会在数据段中定义3个字节，但是并不初始化这些字节的值。这种情况下，这些字节的初始值是未定义的。

DUP也可以用于定义一个重复的数据模式，例如`DB 3 DUP('A', 'B', 'C')`将在数据段中定义一个字符串`'ABCABCABC'`。

请注意，DUP定义的数据元素在编译时就固定下来，不能在运行时改变。如果你需要在运行时创建或修改重复的数据元素，你需要使用其他的方法，例如使用循环结构和赋值指令。

### 数值回送操作符

在8086汇编语言中，一种常见的数值回送操作符是 `OFFSET` 。`OFFSET` 操作符用于获取变量在内存中的地址，而不是其值。在编程中，有时我们需要知道一个变量的地址，而不仅仅是它的值。例如，我们可能需要传递一个变量的地址给一个过程，这样过程就可以修改这个地址处的值。

以下是一些使用 `OFFSET` 的例子：

1. `MOV AX, OFFSET var`：将变量var的地址加载到寄存器AX中。注意这里AX得到的是地址，而不是var的值。

2. `MOV DS, OFFSET dataArray`：将dataArray数组的地址加载到数据段寄存器DS中。之后可以通过使用BX、SI或DI寄存器作为偏移量来访问数组的元素。

3. `LEA BX, var`：使用LEA（Load Effective Address）指令将var的地址加载到BX寄存器中。虽然LEA指令的功能类似于使用OFFSET，但LEA可以计算更复杂的地址表达式，比如基于其他寄存器的偏移。



除了 `OFFSET` 以外，还有其他数值回送操作符

- SEG（取段地址）

  - 操作符格式：    SEG   变量名/标号 
  - 操作符功能：取变量或标号的段基值（段地址）

- TYPE  （取类型值） 

  - 操作符格式：    TYPE   变量名/ 标号 
  - 功能：取变量或标号的类型值。（字节=1、字=2、双字=4等，NEAR=-1，FAR=-2）

- LENGTH （取长度）

  - 操作符格式：    LENGTH   变量名
  - 功能：取分配给变量的字节、字、双字等的个数（说明：只有用DUP重复定义的变量才有意义，否则=1。）

- SIZE  （取总字节数）

  - 操作符格式： SIZE  变量名

  - 操作符功能：SIZE 给出一个变量的总字节数(也就是LENGTH 和TYPE的乘积),即：SIZE=LENGTH ×TYPE



### 属性操作符

PTR是一种类型转换操作符，用于显示地指定操作数的类型。PTR操作符后面通常跟着BYTE PTR、WORD PTR或者DWORD PTR，来指明操作数应该被视为一个字节、一个字或一个双字。

【例】在数据段定义：

```assembly
X  DB  ‘A’
Y  DW   1234H
Z  DD   12345678H      …
```

在代码段中：

```assembly
MOV  AX，Y            	;类型匹配，正确此时AX=1234H
MOV  BL， BYTE  PTR  Y 	;用PTR取出Y变量中的一个字节，BL=34H
MOV  CL， BYTE  PTR  Y+1	;用PTR取出Y变量中的一个字节，CL=12H
MOV  DL，BYTE  PTR Z+3 	;将Z+3所指的字节内容送DL中，DL=12H
```



### 常量

汇编语言的常数主要包括整数、字符、字符串、符号常量与数值表达式等

- 整数 
  - 整数包括:二进制、八进制、十六进制、十进制表示的整数，如:011000101B 、7654Q、0ABCDH、32768D（或32768）
  - 在指令中把二进制、八进制、十六进制、十进制表示的整数叫做立即数
- 字符与字符串
  - 字符与字符串必须用单引号或双引号括起来。例如：“A”为字符常量，“AAA”为字符串常量
- 符号常量
  - 符号常量是用赋值伪指令EQU定义的符号名
  - 赋值伪指令的格式：        `常量名    EQU     表达式`       
  - 例如：X  EQU  100；X为符号常量，在程序中X为100，X是一个常量。
- 数值表达式
  - 以常数(立即数)或符号地址(变量、标号等)作为操作数的地方，均可使用数值表达式。



## 第五部分

### CMP与跳转指令

`CMP` 是比较指令，用于比较两个值。并根据比较结果设置处理器的状态标志。如果结果显示 `参数1` 的值【条件】 `参数2` 的值，则设置处理器的状态标志

以 `JAE` 为例，他的含义是"**不小于跳转**" 当 `参数1` 的值大于等于 `参数2` 的值时将跳转。

以下是一些与 `CMP` 指令相关的常用条件跳转指令：

- `JE`（Jump if Equal）：如果比较结果为相等，则跳转。
- `JNE`（Jump if Not Equal）：如果比较结果为不相等，则跳转。
- `JG`（Jump if Greater）：如果比较结果为大于，则跳转。
- `JGE`（Jump if Greater or Equal）：如果比较结果为大于或等于，则跳转。
- `JL`（Jump if Less）：如果比较结果为小于，则跳转。
- `JLE`（Jump if Less or Equal）：如果比较结果为小于或等于，则跳转。
- `JA`（Jump if Above）：如果无符号数比较结果为大于，则跳转。
- `JAE`（Jump if Above or Equal）：如果无符号数比较结果为大于或等于，则跳转。
- `JB`（Jump if Below）：如果无符号数比较结果为小于，则跳转。
- `JBE`（Jump if Below or Equal）：如果无符号数比较结果为小于或等于，则跳转。

### 循环控制指令

#### LOOP

- 操作符格式：    LOOP   标号 
- 操作符功能：CX ← CX-1 。CX≠0则转到到标号所指的指令，执行循环体；否则退出循环，顺序执行LOOP指令下面的指令。



## 第六部分

### 子程序的编程原则

切分子程序：对于程序的切分没有一个统一的规定，一般根据程序的功能、结构和重复使用的程序段等特性来切分，如：输入/输出程序段、常用算法等。子程序必须具有通用性，逻辑性要强，功能要明确。确定接口参数及参数传递方法入口参数： 把子程序执行前需准备的值或地址称为入口参数。是调用者提供给子程序的信息。出口参数：把子程序返回值或地址称为出口参数。子程序运行后，返给调用者的信息。保存入口/出口参数的方法可以用寄存器或存储器或堆栈来保存.3．保存环境信息由于调用程序（主程序）与子程序通常是分开编写的，而且子程序在主程序的不同地方被多次调用，所用到的寄存器常常出现冲突，子程序是公用程序，所以编写子程序应该注意在子程序中用到的寄存器的内容要保存，在子程序退出之前要恢复寄存器的内容。 4.   堆栈平衡堆栈的操作在程序设计中是非常重要的，堆栈的使用主要在：保存转移指令的返回断点、保存子程序中用到的寄存器的内容、参数传递和子程序本身所用到的堆栈操作。保持堆栈平衡是确保数据弹出的准确性，使程序正确的执行。 主程序调用子程序，子程序返回主程序使用堆栈的顺序（P194）

### 参数的传递

### 子程序的调用与返回指令